// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package aws.sdk.kotlin.services.ec2.model

import aws.smithy.kotlin.runtime.time.Instant

/**
 * Contains the output of GetReservedInstancesExchangeQuote.
 */
class GetReservedInstancesExchangeQuoteResponse private constructor(builder: BuilderImpl) {
    /**
     * The currency of the transaction.
     */
    val currencyCode: String? = builder.currencyCode
    /**
     * If true, the exchange is valid. If false, the exchange cannot be completed.
     */
    val isValidExchange: Boolean? = builder.isValidExchange
    /**
     * The new end date of the reservation term.
     */
    val outputReservedInstancesWillExpireAt: Instant? = builder.outputReservedInstancesWillExpireAt
    /**
     * The total true upfront charge for the exchange.
     */
    val paymentDue: String? = builder.paymentDue
    /**
     * The cost associated with the Reserved Instance.
     */
    val reservedInstanceValueRollup: ReservationValue? = builder.reservedInstanceValueRollup
    /**
     * The configuration of your Convertible Reserved Instances.
     */
    val reservedInstanceValueSet: List<ReservedInstanceReservationValue>? = builder.reservedInstanceValueSet
    /**
     * The cost associated with the Reserved Instance.
     */
    val targetConfigurationValueRollup: ReservationValue? = builder.targetConfigurationValueRollup
    /**
     * The values of the target Convertible Reserved Instances.
     */
    val targetConfigurationValueSet: List<TargetReservationValue>? = builder.targetConfigurationValueSet
    /**
     * Describes the reason why the exchange cannot be completed.
     */
    val validationFailureReason: String? = builder.validationFailureReason

    companion object {
        @JvmStatic
        fun fluentBuilder(): FluentBuilder = BuilderImpl()

        internal fun builder(): DslBuilder = BuilderImpl()

        operator fun invoke(block: DslBuilder.() -> kotlin.Unit): GetReservedInstancesExchangeQuoteResponse = BuilderImpl().apply(block).build()

    }

    override fun toString(): kotlin.String = buildString {
        append("GetReservedInstancesExchangeQuoteResponse(")
        append("currencyCode=$currencyCode,")
        append("isValidExchange=$isValidExchange,")
        append("outputReservedInstancesWillExpireAt=$outputReservedInstancesWillExpireAt,")
        append("paymentDue=$paymentDue,")
        append("reservedInstanceValueRollup=$reservedInstanceValueRollup,")
        append("reservedInstanceValueSet=$reservedInstanceValueSet,")
        append("targetConfigurationValueRollup=$targetConfigurationValueRollup,")
        append("targetConfigurationValueSet=$targetConfigurationValueSet,")
        append("validationFailureReason=$validationFailureReason)")
    }

    override fun hashCode(): kotlin.Int {
        var result = currencyCode?.hashCode() ?: 0
        result = 31 * result + (isValidExchange?.hashCode() ?: 0)
        result = 31 * result + (outputReservedInstancesWillExpireAt?.hashCode() ?: 0)
        result = 31 * result + (paymentDue?.hashCode() ?: 0)
        result = 31 * result + (reservedInstanceValueRollup?.hashCode() ?: 0)
        result = 31 * result + (reservedInstanceValueSet?.hashCode() ?: 0)
        result = 31 * result + (targetConfigurationValueRollup?.hashCode() ?: 0)
        result = 31 * result + (targetConfigurationValueSet?.hashCode() ?: 0)
        result = 31 * result + (validationFailureReason?.hashCode() ?: 0)
        return result
    }

    override fun equals(other: kotlin.Any?): kotlin.Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as GetReservedInstancesExchangeQuoteResponse

        if (currencyCode != other.currencyCode) return false
        if (isValidExchange != other.isValidExchange) return false
        if (outputReservedInstancesWillExpireAt != other.outputReservedInstancesWillExpireAt) return false
        if (paymentDue != other.paymentDue) return false
        if (reservedInstanceValueRollup != other.reservedInstanceValueRollup) return false
        if (reservedInstanceValueSet != other.reservedInstanceValueSet) return false
        if (targetConfigurationValueRollup != other.targetConfigurationValueRollup) return false
        if (targetConfigurationValueSet != other.targetConfigurationValueSet) return false
        if (validationFailureReason != other.validationFailureReason) return false

        return true
    }

    fun copy(block: DslBuilder.() -> kotlin.Unit = {}): GetReservedInstancesExchangeQuoteResponse = BuilderImpl(this).apply(block).build()

    interface FluentBuilder {
        fun build(): GetReservedInstancesExchangeQuoteResponse
        /**
         * The currency of the transaction.
         */
        fun currencyCode(currencyCode: String): FluentBuilder
        /**
         * If true, the exchange is valid. If false, the exchange cannot be completed.
         */
        fun isValidExchange(isValidExchange: Boolean): FluentBuilder
        /**
         * The new end date of the reservation term.
         */
        fun outputReservedInstancesWillExpireAt(outputReservedInstancesWillExpireAt: Instant): FluentBuilder
        /**
         * The total true upfront charge for the exchange.
         */
        fun paymentDue(paymentDue: String): FluentBuilder
        /**
         * The cost associated with the Reserved Instance.
         */
        fun reservedInstanceValueRollup(reservedInstanceValueRollup: ReservationValue): FluentBuilder
        /**
         * The configuration of your Convertible Reserved Instances.
         */
        fun reservedInstanceValueSet(reservedInstanceValueSet: List<ReservedInstanceReservationValue>): FluentBuilder
        /**
         * The cost associated with the Reserved Instance.
         */
        fun targetConfigurationValueRollup(targetConfigurationValueRollup: ReservationValue): FluentBuilder
        /**
         * The values of the target Convertible Reserved Instances.
         */
        fun targetConfigurationValueSet(targetConfigurationValueSet: List<TargetReservationValue>): FluentBuilder
        /**
         * Describes the reason why the exchange cannot be completed.
         */
        fun validationFailureReason(validationFailureReason: String): FluentBuilder
    }

    interface DslBuilder {
        /**
         * The currency of the transaction.
         */
        var currencyCode: String?
        /**
         * If true, the exchange is valid. If false, the exchange cannot be completed.
         */
        var isValidExchange: Boolean?
        /**
         * The new end date of the reservation term.
         */
        var outputReservedInstancesWillExpireAt: Instant?
        /**
         * The total true upfront charge for the exchange.
         */
        var paymentDue: String?
        /**
         * The cost associated with the Reserved Instance.
         */
        var reservedInstanceValueRollup: ReservationValue?
        /**
         * The configuration of your Convertible Reserved Instances.
         */
        var reservedInstanceValueSet: List<ReservedInstanceReservationValue>?
        /**
         * The cost associated with the Reserved Instance.
         */
        var targetConfigurationValueRollup: ReservationValue?
        /**
         * The values of the target Convertible Reserved Instances.
         */
        var targetConfigurationValueSet: List<TargetReservationValue>?
        /**
         * Describes the reason why the exchange cannot be completed.
         */
        var validationFailureReason: String?

        fun build(): GetReservedInstancesExchangeQuoteResponse
        /**
         * construct an [aws.sdk.kotlin.services.ec2.model.ReservationValue] inside the given [block]
         */
        fun reservedInstanceValueRollup(block: ReservationValue.DslBuilder.() -> kotlin.Unit) {
            this.reservedInstanceValueRollup = ReservationValue.invoke(block)
        }
        /**
         * construct an [aws.sdk.kotlin.services.ec2.model.ReservationValue] inside the given [block]
         */
        fun targetConfigurationValueRollup(block: ReservationValue.DslBuilder.() -> kotlin.Unit) {
            this.targetConfigurationValueRollup = ReservationValue.invoke(block)
        }
    }

    private class BuilderImpl() : FluentBuilder, DslBuilder {
        override var currencyCode: String? = null
        override var isValidExchange: Boolean? = null
        override var outputReservedInstancesWillExpireAt: Instant? = null
        override var paymentDue: String? = null
        override var reservedInstanceValueRollup: ReservationValue? = null
        override var reservedInstanceValueSet: List<ReservedInstanceReservationValue>? = null
        override var targetConfigurationValueRollup: ReservationValue? = null
        override var targetConfigurationValueSet: List<TargetReservationValue>? = null
        override var validationFailureReason: String? = null

        constructor(x: GetReservedInstancesExchangeQuoteResponse) : this() {
            this.currencyCode = x.currencyCode
            this.isValidExchange = x.isValidExchange
            this.outputReservedInstancesWillExpireAt = x.outputReservedInstancesWillExpireAt
            this.paymentDue = x.paymentDue
            this.reservedInstanceValueRollup = x.reservedInstanceValueRollup
            this.reservedInstanceValueSet = x.reservedInstanceValueSet
            this.targetConfigurationValueRollup = x.targetConfigurationValueRollup
            this.targetConfigurationValueSet = x.targetConfigurationValueSet
            this.validationFailureReason = x.validationFailureReason
        }

        override fun build(): GetReservedInstancesExchangeQuoteResponse = GetReservedInstancesExchangeQuoteResponse(this)
        override fun currencyCode(currencyCode: String): FluentBuilder = apply { this.currencyCode = currencyCode }
        override fun isValidExchange(isValidExchange: Boolean): FluentBuilder = apply { this.isValidExchange = isValidExchange }
        override fun outputReservedInstancesWillExpireAt(outputReservedInstancesWillExpireAt: Instant): FluentBuilder = apply { this.outputReservedInstancesWillExpireAt = outputReservedInstancesWillExpireAt }
        override fun paymentDue(paymentDue: String): FluentBuilder = apply { this.paymentDue = paymentDue }
        override fun reservedInstanceValueRollup(reservedInstanceValueRollup: ReservationValue): FluentBuilder = apply { this.reservedInstanceValueRollup = reservedInstanceValueRollup }
        override fun reservedInstanceValueSet(reservedInstanceValueSet: List<ReservedInstanceReservationValue>): FluentBuilder = apply { this.reservedInstanceValueSet = reservedInstanceValueSet }
        override fun targetConfigurationValueRollup(targetConfigurationValueRollup: ReservationValue): FluentBuilder = apply { this.targetConfigurationValueRollup = targetConfigurationValueRollup }
        override fun targetConfigurationValueSet(targetConfigurationValueSet: List<TargetReservationValue>): FluentBuilder = apply { this.targetConfigurationValueSet = targetConfigurationValueSet }
        override fun validationFailureReason(validationFailureReason: String): FluentBuilder = apply { this.validationFailureReason = validationFailureReason }
    }
}
