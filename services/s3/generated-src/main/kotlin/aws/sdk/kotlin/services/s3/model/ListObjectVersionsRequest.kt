// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package aws.sdk.kotlin.services.s3.model



class ListObjectVersionsRequest private constructor(builder: BuilderImpl) {
    /**
     * The bucket name that contains the objects.
     */
    val bucket: String? = builder.bucket
    /**
     * A delimiter is a character that you specify to group keys. All keys that contain the
     * same string between the prefix and the first occurrence of the delimiter are
     * grouped under a single result element in CommonPrefixes. These groups are counted as one
     * result against the max-keys limitation. These keys are not returned elsewhere in the
     * response.
     */
    val delimiter: String? = builder.delimiter
    /**
     * Requests Amazon S3 to encode the object keys in the response and specifies the encoding
     * method to use. An object key may contain any Unicode character; however, XML 1.0 parser
     * cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
     * characters that are not supported in XML 1.0, you can add this parameter to request that
     * Amazon S3 encode the keys in the response.
     */
    val encodingType: EncodingType? = builder.encodingType
    /**
     * The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
     */
    val expectedBucketOwner: String? = builder.expectedBucketOwner
    /**
     * Specifies the key to start with when listing objects in a bucket.
     */
    val keyMarker: String? = builder.keyMarker
    /**
     * Sets the maximum number of keys returned in the response. By default the action returns up
     * to 1,000 key names. The response might contain fewer keys but will never contain more. If
     * additional keys satisfy the search criteria, but were not returned because max-keys was
     * exceeded, the response contains <isTruncated>true</isTruncated>. To return the
     * additional keys, see key-marker and version-id-marker.
     */
    val maxKeys: Int = builder.maxKeys
    /**
     * Use this parameter to select only those keys that begin with the specified prefix. You
     * can use prefixes to separate a bucket into different groupings of keys. (You can think of
     * using prefix to make groups in the same way you'd use a folder in a file system.) You can
     * use prefix with delimiter to roll up numerous objects into a single result under
     * CommonPrefixes.
     */
    val prefix: String? = builder.prefix
    /**
     * Specifies the object version you want to start listing from.
     */
    val versionIdMarker: String? = builder.versionIdMarker

    companion object {
        @JvmStatic
        fun fluentBuilder(): FluentBuilder = BuilderImpl()

        internal fun builder(): DslBuilder = BuilderImpl()

        operator fun invoke(block: DslBuilder.() -> kotlin.Unit): ListObjectVersionsRequest = BuilderImpl().apply(block).build()

    }

    override fun toString(): kotlin.String = buildString {
        append("ListObjectVersionsRequest(")
        append("bucket=$bucket,")
        append("delimiter=$delimiter,")
        append("encodingType=$encodingType,")
        append("expectedBucketOwner=$expectedBucketOwner,")
        append("keyMarker=$keyMarker,")
        append("maxKeys=$maxKeys,")
        append("prefix=$prefix,")
        append("versionIdMarker=$versionIdMarker)")
    }

    override fun hashCode(): kotlin.Int {
        var result = bucket?.hashCode() ?: 0
        result = 31 * result + (delimiter?.hashCode() ?: 0)
        result = 31 * result + (encodingType?.hashCode() ?: 0)
        result = 31 * result + (expectedBucketOwner?.hashCode() ?: 0)
        result = 31 * result + (keyMarker?.hashCode() ?: 0)
        result = 31 * result + (maxKeys)
        result = 31 * result + (prefix?.hashCode() ?: 0)
        result = 31 * result + (versionIdMarker?.hashCode() ?: 0)
        return result
    }

    override fun equals(other: kotlin.Any?): kotlin.Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ListObjectVersionsRequest

        if (bucket != other.bucket) return false
        if (delimiter != other.delimiter) return false
        if (encodingType != other.encodingType) return false
        if (expectedBucketOwner != other.expectedBucketOwner) return false
        if (keyMarker != other.keyMarker) return false
        if (maxKeys != other.maxKeys) return false
        if (prefix != other.prefix) return false
        if (versionIdMarker != other.versionIdMarker) return false

        return true
    }

    fun copy(block: DslBuilder.() -> kotlin.Unit = {}): ListObjectVersionsRequest = BuilderImpl(this).apply(block).build()

    interface FluentBuilder {
        fun build(): ListObjectVersionsRequest
        /**
         * The bucket name that contains the objects.
         */
        fun bucket(bucket: String): FluentBuilder
        /**
         * A delimiter is a character that you specify to group keys. All keys that contain the
         * same string between the prefix and the first occurrence of the delimiter are
         * grouped under a single result element in CommonPrefixes. These groups are counted as one
         * result against the max-keys limitation. These keys are not returned elsewhere in the
         * response.
         */
        fun delimiter(delimiter: String): FluentBuilder
        /**
         * Requests Amazon S3 to encode the object keys in the response and specifies the encoding
         * method to use. An object key may contain any Unicode character; however, XML 1.0 parser
         * cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
         * characters that are not supported in XML 1.0, you can add this parameter to request that
         * Amazon S3 encode the keys in the response.
         */
        fun encodingType(encodingType: EncodingType): FluentBuilder
        /**
         * The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
         */
        fun expectedBucketOwner(expectedBucketOwner: String): FluentBuilder
        /**
         * Specifies the key to start with when listing objects in a bucket.
         */
        fun keyMarker(keyMarker: String): FluentBuilder
        /**
         * Sets the maximum number of keys returned in the response. By default the action returns up
         * to 1,000 key names. The response might contain fewer keys but will never contain more. If
         * additional keys satisfy the search criteria, but were not returned because max-keys was
         * exceeded, the response contains <isTruncated>true</isTruncated>. To return the
         * additional keys, see key-marker and version-id-marker.
         */
        fun maxKeys(maxKeys: Int): FluentBuilder
        /**
         * Use this parameter to select only those keys that begin with the specified prefix. You
         * can use prefixes to separate a bucket into different groupings of keys. (You can think of
         * using prefix to make groups in the same way you'd use a folder in a file system.) You can
         * use prefix with delimiter to roll up numerous objects into a single result under
         * CommonPrefixes.
         */
        fun prefix(prefix: String): FluentBuilder
        /**
         * Specifies the object version you want to start listing from.
         */
        fun versionIdMarker(versionIdMarker: String): FluentBuilder
    }

    interface DslBuilder {
        /**
         * The bucket name that contains the objects.
         */
        var bucket: String?
        /**
         * A delimiter is a character that you specify to group keys. All keys that contain the
         * same string between the prefix and the first occurrence of the delimiter are
         * grouped under a single result element in CommonPrefixes. These groups are counted as one
         * result against the max-keys limitation. These keys are not returned elsewhere in the
         * response.
         */
        var delimiter: String?
        /**
         * Requests Amazon S3 to encode the object keys in the response and specifies the encoding
         * method to use. An object key may contain any Unicode character; however, XML 1.0 parser
         * cannot parse some characters, such as characters with an ASCII value from 0 to 10. For
         * characters that are not supported in XML 1.0, you can add this parameter to request that
         * Amazon S3 encode the keys in the response.
         */
        var encodingType: EncodingType?
        /**
         * The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
         */
        var expectedBucketOwner: String?
        /**
         * Specifies the key to start with when listing objects in a bucket.
         */
        var keyMarker: String?
        /**
         * Sets the maximum number of keys returned in the response. By default the action returns up
         * to 1,000 key names. The response might contain fewer keys but will never contain more. If
         * additional keys satisfy the search criteria, but were not returned because max-keys was
         * exceeded, the response contains <isTruncated>true</isTruncated>. To return the
         * additional keys, see key-marker and version-id-marker.
         */
        var maxKeys: Int
        /**
         * Use this parameter to select only those keys that begin with the specified prefix. You
         * can use prefixes to separate a bucket into different groupings of keys. (You can think of
         * using prefix to make groups in the same way you'd use a folder in a file system.) You can
         * use prefix with delimiter to roll up numerous objects into a single result under
         * CommonPrefixes.
         */
        var prefix: String?
        /**
         * Specifies the object version you want to start listing from.
         */
        var versionIdMarker: String?

        fun build(): ListObjectVersionsRequest
    }

    private class BuilderImpl() : FluentBuilder, DslBuilder {
        override var bucket: String? = null
        override var delimiter: String? = null
        override var encodingType: EncodingType? = null
        override var expectedBucketOwner: String? = null
        override var keyMarker: String? = null
        override var maxKeys: Int = 0
        override var prefix: String? = null
        override var versionIdMarker: String? = null

        constructor(x: ListObjectVersionsRequest) : this() {
            this.bucket = x.bucket
            this.delimiter = x.delimiter
            this.encodingType = x.encodingType
            this.expectedBucketOwner = x.expectedBucketOwner
            this.keyMarker = x.keyMarker
            this.maxKeys = x.maxKeys
            this.prefix = x.prefix
            this.versionIdMarker = x.versionIdMarker
        }

        override fun build(): ListObjectVersionsRequest = ListObjectVersionsRequest(this)
        override fun bucket(bucket: String): FluentBuilder = apply { this.bucket = bucket }
        override fun delimiter(delimiter: String): FluentBuilder = apply { this.delimiter = delimiter }
        override fun encodingType(encodingType: EncodingType): FluentBuilder = apply { this.encodingType = encodingType }
        override fun expectedBucketOwner(expectedBucketOwner: String): FluentBuilder = apply { this.expectedBucketOwner = expectedBucketOwner }
        override fun keyMarker(keyMarker: String): FluentBuilder = apply { this.keyMarker = keyMarker }
        override fun maxKeys(maxKeys: Int): FluentBuilder = apply { this.maxKeys = maxKeys }
        override fun prefix(prefix: String): FluentBuilder = apply { this.prefix = prefix }
        override fun versionIdMarker(versionIdMarker: String): FluentBuilder = apply { this.versionIdMarker = versionIdMarker }
    }
}
