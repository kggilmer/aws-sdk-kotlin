// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package aws.sdk.kotlin.services.s3.model



class ListObjectVersionsResponse private constructor(builder: BuilderImpl) {
    /**
     * All of the keys rolled up into a common prefix count as a single return when calculating
     * the number of returns.
     */
    val commonPrefixes: List<CommonPrefix>? = builder.commonPrefixes
    /**
     * Container for an object that is a delete marker.
     */
    val deleteMarkers: List<DeleteMarkerEntry>? = builder.deleteMarkers
    /**
     * The delimiter grouping the included keys. A delimiter is a character that you specify to
     * group keys. All keys that contain the same string between the prefix and the first
     * occurrence of the delimiter are grouped under a single result element in
     * CommonPrefixes. These groups are counted as one result against the max-keys
     * limitation. These keys are not returned elsewhere in the response.
     */
    val delimiter: String? = builder.delimiter
    /**
     * Encoding type used by Amazon S3 to encode object key names in the XML response.
     * If you specify encoding-type request parameter, Amazon S3 includes this element in the
     * response, and returns encoded key name values in the following response elements:
     * KeyMarker, NextKeyMarker, Prefix, Key, and Delimiter.
     */
    val encodingType: EncodingType? = builder.encodingType
    /**
     * A flag that indicates whether Amazon S3 returned all of the results that satisfied the search
     * criteria. If your results were truncated, you can make a follow-up paginated request using
     * the NextKeyMarker and NextVersionIdMarker response parameters as a starting place in
     * another request to return the rest of the results.
     */
    val isTruncated: Boolean = builder.isTruncated
    /**
     * Marks the last key returned in a truncated response.
     */
    val keyMarker: String? = builder.keyMarker
    /**
     * Specifies the maximum number of objects to return.
     */
    val maxKeys: Int = builder.maxKeys
    /**
     * The bucket name.
     */
    val name: String? = builder.name
    /**
     * When the number of responses exceeds the value of MaxKeys,
     * NextKeyMarker specifies the first key not returned that satisfies the
     * search criteria. Use this value for the key-marker request parameter in a subsequent
     * request.
     */
    val nextKeyMarker: String? = builder.nextKeyMarker
    /**
     * When the number of responses exceeds the value of MaxKeys,
     * NextVersionIdMarker specifies the first object version not returned that
     * satisfies the search criteria. Use this value for the version-id-marker request parameter
     * in a subsequent request.
     */
    val nextVersionIdMarker: String? = builder.nextVersionIdMarker
    /**
     * Selects objects that start with the value supplied by this parameter.
     */
    val prefix: String? = builder.prefix
    /**
     * Marks the last version of the key returned in a truncated response.
     */
    val versionIdMarker: String? = builder.versionIdMarker
    /**
     * Container for version information.
     */
    val versions: List<ObjectVersion>? = builder.versions

    companion object {
        @JvmStatic
        fun fluentBuilder(): FluentBuilder = BuilderImpl()

        internal fun builder(): DslBuilder = BuilderImpl()

        operator fun invoke(block: DslBuilder.() -> kotlin.Unit): ListObjectVersionsResponse = BuilderImpl().apply(block).build()

    }

    override fun toString(): kotlin.String = buildString {
        append("ListObjectVersionsResponse(")
        append("commonPrefixes=$commonPrefixes,")
        append("deleteMarkers=$deleteMarkers,")
        append("delimiter=$delimiter,")
        append("encodingType=$encodingType,")
        append("isTruncated=$isTruncated,")
        append("keyMarker=$keyMarker,")
        append("maxKeys=$maxKeys,")
        append("name=$name,")
        append("nextKeyMarker=$nextKeyMarker,")
        append("nextVersionIdMarker=$nextVersionIdMarker,")
        append("prefix=$prefix,")
        append("versionIdMarker=$versionIdMarker,")
        append("versions=$versions)")
    }

    override fun hashCode(): kotlin.Int {
        var result = commonPrefixes?.hashCode() ?: 0
        result = 31 * result + (deleteMarkers?.hashCode() ?: 0)
        result = 31 * result + (delimiter?.hashCode() ?: 0)
        result = 31 * result + (encodingType?.hashCode() ?: 0)
        result = 31 * result + (isTruncated.hashCode())
        result = 31 * result + (keyMarker?.hashCode() ?: 0)
        result = 31 * result + (maxKeys)
        result = 31 * result + (name?.hashCode() ?: 0)
        result = 31 * result + (nextKeyMarker?.hashCode() ?: 0)
        result = 31 * result + (nextVersionIdMarker?.hashCode() ?: 0)
        result = 31 * result + (prefix?.hashCode() ?: 0)
        result = 31 * result + (versionIdMarker?.hashCode() ?: 0)
        result = 31 * result + (versions?.hashCode() ?: 0)
        return result
    }

    override fun equals(other: kotlin.Any?): kotlin.Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ListObjectVersionsResponse

        if (commonPrefixes != other.commonPrefixes) return false
        if (deleteMarkers != other.deleteMarkers) return false
        if (delimiter != other.delimiter) return false
        if (encodingType != other.encodingType) return false
        if (isTruncated != other.isTruncated) return false
        if (keyMarker != other.keyMarker) return false
        if (maxKeys != other.maxKeys) return false
        if (name != other.name) return false
        if (nextKeyMarker != other.nextKeyMarker) return false
        if (nextVersionIdMarker != other.nextVersionIdMarker) return false
        if (prefix != other.prefix) return false
        if (versionIdMarker != other.versionIdMarker) return false
        if (versions != other.versions) return false

        return true
    }

    fun copy(block: DslBuilder.() -> kotlin.Unit = {}): ListObjectVersionsResponse = BuilderImpl(this).apply(block).build()

    interface FluentBuilder {
        fun build(): ListObjectVersionsResponse
        /**
         * All of the keys rolled up into a common prefix count as a single return when calculating
         * the number of returns.
         */
        fun commonPrefixes(commonPrefixes: List<CommonPrefix>): FluentBuilder
        /**
         * Container for an object that is a delete marker.
         */
        fun deleteMarkers(deleteMarkers: List<DeleteMarkerEntry>): FluentBuilder
        /**
         * The delimiter grouping the included keys. A delimiter is a character that you specify to
         * group keys. All keys that contain the same string between the prefix and the first
         * occurrence of the delimiter are grouped under a single result element in
         * CommonPrefixes. These groups are counted as one result against the max-keys
         * limitation. These keys are not returned elsewhere in the response.
         */
        fun delimiter(delimiter: String): FluentBuilder
        /**
         * Encoding type used by Amazon S3 to encode object key names in the XML response.
         * If you specify encoding-type request parameter, Amazon S3 includes this element in the
         * response, and returns encoded key name values in the following response elements:
         * KeyMarker, NextKeyMarker, Prefix, Key, and Delimiter.
         */
        fun encodingType(encodingType: EncodingType): FluentBuilder
        /**
         * A flag that indicates whether Amazon S3 returned all of the results that satisfied the search
         * criteria. If your results were truncated, you can make a follow-up paginated request using
         * the NextKeyMarker and NextVersionIdMarker response parameters as a starting place in
         * another request to return the rest of the results.
         */
        fun isTruncated(isTruncated: Boolean): FluentBuilder
        /**
         * Marks the last key returned in a truncated response.
         */
        fun keyMarker(keyMarker: String): FluentBuilder
        /**
         * Specifies the maximum number of objects to return.
         */
        fun maxKeys(maxKeys: Int): FluentBuilder
        /**
         * The bucket name.
         */
        fun name(name: String): FluentBuilder
        /**
         * When the number of responses exceeds the value of MaxKeys,
         * NextKeyMarker specifies the first key not returned that satisfies the
         * search criteria. Use this value for the key-marker request parameter in a subsequent
         * request.
         */
        fun nextKeyMarker(nextKeyMarker: String): FluentBuilder
        /**
         * When the number of responses exceeds the value of MaxKeys,
         * NextVersionIdMarker specifies the first object version not returned that
         * satisfies the search criteria. Use this value for the version-id-marker request parameter
         * in a subsequent request.
         */
        fun nextVersionIdMarker(nextVersionIdMarker: String): FluentBuilder
        /**
         * Selects objects that start with the value supplied by this parameter.
         */
        fun prefix(prefix: String): FluentBuilder
        /**
         * Marks the last version of the key returned in a truncated response.
         */
        fun versionIdMarker(versionIdMarker: String): FluentBuilder
        /**
         * Container for version information.
         */
        fun versions(versions: List<ObjectVersion>): FluentBuilder
    }

    interface DslBuilder {
        /**
         * All of the keys rolled up into a common prefix count as a single return when calculating
         * the number of returns.
         */
        var commonPrefixes: List<CommonPrefix>?
        /**
         * Container for an object that is a delete marker.
         */
        var deleteMarkers: List<DeleteMarkerEntry>?
        /**
         * The delimiter grouping the included keys. A delimiter is a character that you specify to
         * group keys. All keys that contain the same string between the prefix and the first
         * occurrence of the delimiter are grouped under a single result element in
         * CommonPrefixes. These groups are counted as one result against the max-keys
         * limitation. These keys are not returned elsewhere in the response.
         */
        var delimiter: String?
        /**
         * Encoding type used by Amazon S3 to encode object key names in the XML response.
         * If you specify encoding-type request parameter, Amazon S3 includes this element in the
         * response, and returns encoded key name values in the following response elements:
         * KeyMarker, NextKeyMarker, Prefix, Key, and Delimiter.
         */
        var encodingType: EncodingType?
        /**
         * A flag that indicates whether Amazon S3 returned all of the results that satisfied the search
         * criteria. If your results were truncated, you can make a follow-up paginated request using
         * the NextKeyMarker and NextVersionIdMarker response parameters as a starting place in
         * another request to return the rest of the results.
         */
        var isTruncated: Boolean
        /**
         * Marks the last key returned in a truncated response.
         */
        var keyMarker: String?
        /**
         * Specifies the maximum number of objects to return.
         */
        var maxKeys: Int
        /**
         * The bucket name.
         */
        var name: String?
        /**
         * When the number of responses exceeds the value of MaxKeys,
         * NextKeyMarker specifies the first key not returned that satisfies the
         * search criteria. Use this value for the key-marker request parameter in a subsequent
         * request.
         */
        var nextKeyMarker: String?
        /**
         * When the number of responses exceeds the value of MaxKeys,
         * NextVersionIdMarker specifies the first object version not returned that
         * satisfies the search criteria. Use this value for the version-id-marker request parameter
         * in a subsequent request.
         */
        var nextVersionIdMarker: String?
        /**
         * Selects objects that start with the value supplied by this parameter.
         */
        var prefix: String?
        /**
         * Marks the last version of the key returned in a truncated response.
         */
        var versionIdMarker: String?
        /**
         * Container for version information.
         */
        var versions: List<ObjectVersion>?

        fun build(): ListObjectVersionsResponse
    }

    private class BuilderImpl() : FluentBuilder, DslBuilder {
        override var commonPrefixes: List<CommonPrefix>? = null
        override var deleteMarkers: List<DeleteMarkerEntry>? = null
        override var delimiter: String? = null
        override var encodingType: EncodingType? = null
        override var isTruncated: Boolean = false
        override var keyMarker: String? = null
        override var maxKeys: Int = 0
        override var name: String? = null
        override var nextKeyMarker: String? = null
        override var nextVersionIdMarker: String? = null
        override var prefix: String? = null
        override var versionIdMarker: String? = null
        override var versions: List<ObjectVersion>? = null

        constructor(x: ListObjectVersionsResponse) : this() {
            this.commonPrefixes = x.commonPrefixes
            this.deleteMarkers = x.deleteMarkers
            this.delimiter = x.delimiter
            this.encodingType = x.encodingType
            this.isTruncated = x.isTruncated
            this.keyMarker = x.keyMarker
            this.maxKeys = x.maxKeys
            this.name = x.name
            this.nextKeyMarker = x.nextKeyMarker
            this.nextVersionIdMarker = x.nextVersionIdMarker
            this.prefix = x.prefix
            this.versionIdMarker = x.versionIdMarker
            this.versions = x.versions
        }

        override fun build(): ListObjectVersionsResponse = ListObjectVersionsResponse(this)
        override fun commonPrefixes(commonPrefixes: List<CommonPrefix>): FluentBuilder = apply { this.commonPrefixes = commonPrefixes }
        override fun deleteMarkers(deleteMarkers: List<DeleteMarkerEntry>): FluentBuilder = apply { this.deleteMarkers = deleteMarkers }
        override fun delimiter(delimiter: String): FluentBuilder = apply { this.delimiter = delimiter }
        override fun encodingType(encodingType: EncodingType): FluentBuilder = apply { this.encodingType = encodingType }
        override fun isTruncated(isTruncated: Boolean): FluentBuilder = apply { this.isTruncated = isTruncated }
        override fun keyMarker(keyMarker: String): FluentBuilder = apply { this.keyMarker = keyMarker }
        override fun maxKeys(maxKeys: Int): FluentBuilder = apply { this.maxKeys = maxKeys }
        override fun name(name: String): FluentBuilder = apply { this.name = name }
        override fun nextKeyMarker(nextKeyMarker: String): FluentBuilder = apply { this.nextKeyMarker = nextKeyMarker }
        override fun nextVersionIdMarker(nextVersionIdMarker: String): FluentBuilder = apply { this.nextVersionIdMarker = nextVersionIdMarker }
        override fun prefix(prefix: String): FluentBuilder = apply { this.prefix = prefix }
        override fun versionIdMarker(versionIdMarker: String): FluentBuilder = apply { this.versionIdMarker = versionIdMarker }
        override fun versions(versions: List<ObjectVersion>): FluentBuilder = apply { this.versions = versions }
    }
}
