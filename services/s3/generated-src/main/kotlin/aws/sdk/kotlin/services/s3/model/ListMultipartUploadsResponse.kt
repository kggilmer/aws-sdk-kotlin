// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package aws.sdk.kotlin.services.s3.model



class ListMultipartUploadsResponse private constructor(builder: BuilderImpl) {
    /**
     * The name of the bucket to which the multipart upload was initiated. Does not return the access point ARN or access point alias if used.
     */
    val bucket: String? = builder.bucket
    /**
     * If you specify a delimiter in the request, then the result returns each distinct key
     * prefix containing the delimiter in a CommonPrefixes element. The distinct key
     * prefixes are returned in the Prefix child element.
     */
    val commonPrefixes: List<CommonPrefix>? = builder.commonPrefixes
    /**
     * Contains the delimiter you specified in the request. If you don't specify a delimiter in
     * your request, this element is absent from the response.
     */
    val delimiter: String? = builder.delimiter
    /**
     * Encoding type used by Amazon S3 to encode object keys in the response.
     * If you specify encoding-type request parameter, Amazon S3 includes this element
     * in the response, and returns encoded key name values in the following response
     * elements:
     * Delimiter, KeyMarker, Prefix,
     * NextKeyMarker, Key.
     */
    val encodingType: EncodingType? = builder.encodingType
    /**
     * Indicates whether the returned list of multipart uploads is truncated. A value of true
     * indicates that the list was truncated. The list can be truncated if the number of multipart
     * uploads exceeds the limit allowed or specified by max uploads.
     */
    val isTruncated: Boolean = builder.isTruncated
    /**
     * The key at or after which the listing began.
     */
    val keyMarker: String? = builder.keyMarker
    /**
     * Maximum number of multipart uploads that could have been included in the
     * response.
     */
    val maxUploads: Int = builder.maxUploads
    /**
     * When a list is truncated, this element specifies the value that should be used for the
     * key-marker request parameter in a subsequent request.
     */
    val nextKeyMarker: String? = builder.nextKeyMarker
    /**
     * When a list is truncated, this element specifies the value that should be used for the
     * upload-id-marker request parameter in a subsequent request.
     */
    val nextUploadIdMarker: String? = builder.nextUploadIdMarker
    /**
     * When a prefix is provided in the request, this field contains the specified prefix. The
     * result contains only keys starting with the specified prefix.
     */
    val prefix: String? = builder.prefix
    /**
     * Upload ID after which listing began.
     */
    val uploadIdMarker: String? = builder.uploadIdMarker
    /**
     * Container for elements related to a particular multipart upload. A response can contain
     * zero or more Upload elements.
     */
    val uploads: List<MultipartUpload>? = builder.uploads

    companion object {
        @JvmStatic
        fun fluentBuilder(): FluentBuilder = BuilderImpl()

        internal fun builder(): DslBuilder = BuilderImpl()

        operator fun invoke(block: DslBuilder.() -> kotlin.Unit): ListMultipartUploadsResponse = BuilderImpl().apply(block).build()

    }

    override fun toString(): kotlin.String = buildString {
        append("ListMultipartUploadsResponse(")
        append("bucket=$bucket,")
        append("commonPrefixes=$commonPrefixes,")
        append("delimiter=$delimiter,")
        append("encodingType=$encodingType,")
        append("isTruncated=$isTruncated,")
        append("keyMarker=$keyMarker,")
        append("maxUploads=$maxUploads,")
        append("nextKeyMarker=$nextKeyMarker,")
        append("nextUploadIdMarker=$nextUploadIdMarker,")
        append("prefix=$prefix,")
        append("uploadIdMarker=$uploadIdMarker,")
        append("uploads=$uploads)")
    }

    override fun hashCode(): kotlin.Int {
        var result = bucket?.hashCode() ?: 0
        result = 31 * result + (commonPrefixes?.hashCode() ?: 0)
        result = 31 * result + (delimiter?.hashCode() ?: 0)
        result = 31 * result + (encodingType?.hashCode() ?: 0)
        result = 31 * result + (isTruncated.hashCode())
        result = 31 * result + (keyMarker?.hashCode() ?: 0)
        result = 31 * result + (maxUploads)
        result = 31 * result + (nextKeyMarker?.hashCode() ?: 0)
        result = 31 * result + (nextUploadIdMarker?.hashCode() ?: 0)
        result = 31 * result + (prefix?.hashCode() ?: 0)
        result = 31 * result + (uploadIdMarker?.hashCode() ?: 0)
        result = 31 * result + (uploads?.hashCode() ?: 0)
        return result
    }

    override fun equals(other: kotlin.Any?): kotlin.Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ListMultipartUploadsResponse

        if (bucket != other.bucket) return false
        if (commonPrefixes != other.commonPrefixes) return false
        if (delimiter != other.delimiter) return false
        if (encodingType != other.encodingType) return false
        if (isTruncated != other.isTruncated) return false
        if (keyMarker != other.keyMarker) return false
        if (maxUploads != other.maxUploads) return false
        if (nextKeyMarker != other.nextKeyMarker) return false
        if (nextUploadIdMarker != other.nextUploadIdMarker) return false
        if (prefix != other.prefix) return false
        if (uploadIdMarker != other.uploadIdMarker) return false
        if (uploads != other.uploads) return false

        return true
    }

    fun copy(block: DslBuilder.() -> kotlin.Unit = {}): ListMultipartUploadsResponse = BuilderImpl(this).apply(block).build()

    interface FluentBuilder {
        fun build(): ListMultipartUploadsResponse
        /**
         * The name of the bucket to which the multipart upload was initiated. Does not return the access point ARN or access point alias if used.
         */
        fun bucket(bucket: String): FluentBuilder
        /**
         * If you specify a delimiter in the request, then the result returns each distinct key
         * prefix containing the delimiter in a CommonPrefixes element. The distinct key
         * prefixes are returned in the Prefix child element.
         */
        fun commonPrefixes(commonPrefixes: List<CommonPrefix>): FluentBuilder
        /**
         * Contains the delimiter you specified in the request. If you don't specify a delimiter in
         * your request, this element is absent from the response.
         */
        fun delimiter(delimiter: String): FluentBuilder
        /**
         * Encoding type used by Amazon S3 to encode object keys in the response.
         * If you specify encoding-type request parameter, Amazon S3 includes this element
         * in the response, and returns encoded key name values in the following response
         * elements:
         * Delimiter, KeyMarker, Prefix,
         * NextKeyMarker, Key.
         */
        fun encodingType(encodingType: EncodingType): FluentBuilder
        /**
         * Indicates whether the returned list of multipart uploads is truncated. A value of true
         * indicates that the list was truncated. The list can be truncated if the number of multipart
         * uploads exceeds the limit allowed or specified by max uploads.
         */
        fun isTruncated(isTruncated: Boolean): FluentBuilder
        /**
         * The key at or after which the listing began.
         */
        fun keyMarker(keyMarker: String): FluentBuilder
        /**
         * Maximum number of multipart uploads that could have been included in the
         * response.
         */
        fun maxUploads(maxUploads: Int): FluentBuilder
        /**
         * When a list is truncated, this element specifies the value that should be used for the
         * key-marker request parameter in a subsequent request.
         */
        fun nextKeyMarker(nextKeyMarker: String): FluentBuilder
        /**
         * When a list is truncated, this element specifies the value that should be used for the
         * upload-id-marker request parameter in a subsequent request.
         */
        fun nextUploadIdMarker(nextUploadIdMarker: String): FluentBuilder
        /**
         * When a prefix is provided in the request, this field contains the specified prefix. The
         * result contains only keys starting with the specified prefix.
         */
        fun prefix(prefix: String): FluentBuilder
        /**
         * Upload ID after which listing began.
         */
        fun uploadIdMarker(uploadIdMarker: String): FluentBuilder
        /**
         * Container for elements related to a particular multipart upload. A response can contain
         * zero or more Upload elements.
         */
        fun uploads(uploads: List<MultipartUpload>): FluentBuilder
    }

    interface DslBuilder {
        /**
         * The name of the bucket to which the multipart upload was initiated. Does not return the access point ARN or access point alias if used.
         */
        var bucket: String?
        /**
         * If you specify a delimiter in the request, then the result returns each distinct key
         * prefix containing the delimiter in a CommonPrefixes element. The distinct key
         * prefixes are returned in the Prefix child element.
         */
        var commonPrefixes: List<CommonPrefix>?
        /**
         * Contains the delimiter you specified in the request. If you don't specify a delimiter in
         * your request, this element is absent from the response.
         */
        var delimiter: String?
        /**
         * Encoding type used by Amazon S3 to encode object keys in the response.
         * If you specify encoding-type request parameter, Amazon S3 includes this element
         * in the response, and returns encoded key name values in the following response
         * elements:
         * Delimiter, KeyMarker, Prefix,
         * NextKeyMarker, Key.
         */
        var encodingType: EncodingType?
        /**
         * Indicates whether the returned list of multipart uploads is truncated. A value of true
         * indicates that the list was truncated. The list can be truncated if the number of multipart
         * uploads exceeds the limit allowed or specified by max uploads.
         */
        var isTruncated: Boolean
        /**
         * The key at or after which the listing began.
         */
        var keyMarker: String?
        /**
         * Maximum number of multipart uploads that could have been included in the
         * response.
         */
        var maxUploads: Int
        /**
         * When a list is truncated, this element specifies the value that should be used for the
         * key-marker request parameter in a subsequent request.
         */
        var nextKeyMarker: String?
        /**
         * When a list is truncated, this element specifies the value that should be used for the
         * upload-id-marker request parameter in a subsequent request.
         */
        var nextUploadIdMarker: String?
        /**
         * When a prefix is provided in the request, this field contains the specified prefix. The
         * result contains only keys starting with the specified prefix.
         */
        var prefix: String?
        /**
         * Upload ID after which listing began.
         */
        var uploadIdMarker: String?
        /**
         * Container for elements related to a particular multipart upload. A response can contain
         * zero or more Upload elements.
         */
        var uploads: List<MultipartUpload>?

        fun build(): ListMultipartUploadsResponse
    }

    private class BuilderImpl() : FluentBuilder, DslBuilder {
        override var bucket: String? = null
        override var commonPrefixes: List<CommonPrefix>? = null
        override var delimiter: String? = null
        override var encodingType: EncodingType? = null
        override var isTruncated: Boolean = false
        override var keyMarker: String? = null
        override var maxUploads: Int = 0
        override var nextKeyMarker: String? = null
        override var nextUploadIdMarker: String? = null
        override var prefix: String? = null
        override var uploadIdMarker: String? = null
        override var uploads: List<MultipartUpload>? = null

        constructor(x: ListMultipartUploadsResponse) : this() {
            this.bucket = x.bucket
            this.commonPrefixes = x.commonPrefixes
            this.delimiter = x.delimiter
            this.encodingType = x.encodingType
            this.isTruncated = x.isTruncated
            this.keyMarker = x.keyMarker
            this.maxUploads = x.maxUploads
            this.nextKeyMarker = x.nextKeyMarker
            this.nextUploadIdMarker = x.nextUploadIdMarker
            this.prefix = x.prefix
            this.uploadIdMarker = x.uploadIdMarker
            this.uploads = x.uploads
        }

        override fun build(): ListMultipartUploadsResponse = ListMultipartUploadsResponse(this)
        override fun bucket(bucket: String): FluentBuilder = apply { this.bucket = bucket }
        override fun commonPrefixes(commonPrefixes: List<CommonPrefix>): FluentBuilder = apply { this.commonPrefixes = commonPrefixes }
        override fun delimiter(delimiter: String): FluentBuilder = apply { this.delimiter = delimiter }
        override fun encodingType(encodingType: EncodingType): FluentBuilder = apply { this.encodingType = encodingType }
        override fun isTruncated(isTruncated: Boolean): FluentBuilder = apply { this.isTruncated = isTruncated }
        override fun keyMarker(keyMarker: String): FluentBuilder = apply { this.keyMarker = keyMarker }
        override fun maxUploads(maxUploads: Int): FluentBuilder = apply { this.maxUploads = maxUploads }
        override fun nextKeyMarker(nextKeyMarker: String): FluentBuilder = apply { this.nextKeyMarker = nextKeyMarker }
        override fun nextUploadIdMarker(nextUploadIdMarker: String): FluentBuilder = apply { this.nextUploadIdMarker = nextUploadIdMarker }
        override fun prefix(prefix: String): FluentBuilder = apply { this.prefix = prefix }
        override fun uploadIdMarker(uploadIdMarker: String): FluentBuilder = apply { this.uploadIdMarker = uploadIdMarker }
        override fun uploads(uploads: List<MultipartUpload>): FluentBuilder = apply { this.uploads = uploads }
    }
}
