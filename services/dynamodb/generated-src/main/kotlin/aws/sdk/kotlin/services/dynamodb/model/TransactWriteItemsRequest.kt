// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package aws.sdk.kotlin.services.dynamodb.model



class TransactWriteItemsRequest private constructor(builder: BuilderImpl) {
    /**
     * Providing a ClientRequestToken makes the call to TransactWriteItems
     * idempotent, meaning that multiple identical calls have the same effect as one single call.
     * Although multiple identical calls using the same client request token produce the same
     * result on the server (no side effects), the responses to the calls might not be the
     * same. If the ReturnConsumedCapacity> parameter is set, then the initial
     * TransactWriteItems call returns the amount of write capacity units
     * consumed in making the changes. Subsequent TransactWriteItems calls with
     * the same client token return the number of read capacity units consumed in reading the
     * item.
     * A client request token is valid for 10 minutes after the first request that uses it is
     * completed. After 10 minutes, any request with the same client token is treated as a new
     * request. Do not resubmit the same request with the same client token for more than 10
     * minutes, or the result might not be idempotent.
     * If you submit a request with the same client token but a change in other parameters
     * within the 10-minute idempotency window, DynamoDB returns an
     * IdempotentParameterMismatch exception.
     */
    val clientRequestToken: String? = builder.clientRequestToken
    /**
     * Determines the level of detail about provisioned throughput consumption that is returned in the response:
     * INDEXES - The response includes the aggregate ConsumedCapacity for the operation, together with ConsumedCapacity for each table and secondary index that was accessed.
     * Note that some operations, such as GetItem and BatchGetItem, do not access any indexes at all.  In these cases, specifying INDEXES will only return ConsumedCapacity information for table(s).
     * TOTAL - The response includes only the aggregate ConsumedCapacity for the operation.
     * NONE - No ConsumedCapacity details are included in the response.
     */
    val returnConsumedCapacity: ReturnConsumedCapacity? = builder.returnConsumedCapacity
    /**
     * Determines whether item collection metrics are returned. If set to
     * SIZE, the response includes statistics about item collections (if any), that
     * were modified during the operation and are returned in the response.
     * If set to NONE (the default), no statistics are returned.
     */
    val returnItemCollectionMetrics: ReturnItemCollectionMetrics? = builder.returnItemCollectionMetrics
    /**
     * An ordered array of up to 25 TransactWriteItem objects, each of which
     * contains a ConditionCheck, Put, Update, or
     * Delete object. These can operate on items in different tables, but the
     * tables must reside in the same AWS account and Region, and no two of them can operate on
     * the same item.
     */
    val transactItems: List<TransactWriteItem>? = builder.transactItems

    companion object {
        @JvmStatic
        fun fluentBuilder(): FluentBuilder = BuilderImpl()

        internal fun builder(): DslBuilder = BuilderImpl()

        operator fun invoke(block: DslBuilder.() -> kotlin.Unit): TransactWriteItemsRequest = BuilderImpl().apply(block).build()

    }

    override fun toString(): kotlin.String = buildString {
        append("TransactWriteItemsRequest(")
        append("clientRequestToken=$clientRequestToken,")
        append("returnConsumedCapacity=$returnConsumedCapacity,")
        append("returnItemCollectionMetrics=$returnItemCollectionMetrics,")
        append("transactItems=$transactItems)")
    }

    override fun hashCode(): kotlin.Int {
        var result = clientRequestToken?.hashCode() ?: 0
        result = 31 * result + (returnConsumedCapacity?.hashCode() ?: 0)
        result = 31 * result + (returnItemCollectionMetrics?.hashCode() ?: 0)
        result = 31 * result + (transactItems?.hashCode() ?: 0)
        return result
    }

    override fun equals(other: kotlin.Any?): kotlin.Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as TransactWriteItemsRequest

        if (clientRequestToken != other.clientRequestToken) return false
        if (returnConsumedCapacity != other.returnConsumedCapacity) return false
        if (returnItemCollectionMetrics != other.returnItemCollectionMetrics) return false
        if (transactItems != other.transactItems) return false

        return true
    }

    fun copy(block: DslBuilder.() -> kotlin.Unit = {}): TransactWriteItemsRequest = BuilderImpl(this).apply(block).build()

    interface FluentBuilder {
        fun build(): TransactWriteItemsRequest
        /**
         * Providing a ClientRequestToken makes the call to TransactWriteItems
         * idempotent, meaning that multiple identical calls have the same effect as one single call.
         * Although multiple identical calls using the same client request token produce the same
         * result on the server (no side effects), the responses to the calls might not be the
         * same. If the ReturnConsumedCapacity> parameter is set, then the initial
         * TransactWriteItems call returns the amount of write capacity units
         * consumed in making the changes. Subsequent TransactWriteItems calls with
         * the same client token return the number of read capacity units consumed in reading the
         * item.
         * A client request token is valid for 10 minutes after the first request that uses it is
         * completed. After 10 minutes, any request with the same client token is treated as a new
         * request. Do not resubmit the same request with the same client token for more than 10
         * minutes, or the result might not be idempotent.
         * If you submit a request with the same client token but a change in other parameters
         * within the 10-minute idempotency window, DynamoDB returns an
         * IdempotentParameterMismatch exception.
         */
        fun clientRequestToken(clientRequestToken: String): FluentBuilder
        /**
         * Determines the level of detail about provisioned throughput consumption that is returned in the response:
         * INDEXES - The response includes the aggregate ConsumedCapacity for the operation, together with ConsumedCapacity for each table and secondary index that was accessed.
         * Note that some operations, such as GetItem and BatchGetItem, do not access any indexes at all.  In these cases, specifying INDEXES will only return ConsumedCapacity information for table(s).
         * TOTAL - The response includes only the aggregate ConsumedCapacity for the operation.
         * NONE - No ConsumedCapacity details are included in the response.
         */
        fun returnConsumedCapacity(returnConsumedCapacity: ReturnConsumedCapacity): FluentBuilder
        /**
         * Determines whether item collection metrics are returned. If set to
         * SIZE, the response includes statistics about item collections (if any), that
         * were modified during the operation and are returned in the response.
         * If set to NONE (the default), no statistics are returned.
         */
        fun returnItemCollectionMetrics(returnItemCollectionMetrics: ReturnItemCollectionMetrics): FluentBuilder
        /**
         * An ordered array of up to 25 TransactWriteItem objects, each of which
         * contains a ConditionCheck, Put, Update, or
         * Delete object. These can operate on items in different tables, but the
         * tables must reside in the same AWS account and Region, and no two of them can operate on
         * the same item.
         */
        fun transactItems(transactItems: List<TransactWriteItem>): FluentBuilder
    }

    interface DslBuilder {
        /**
         * Providing a ClientRequestToken makes the call to TransactWriteItems
         * idempotent, meaning that multiple identical calls have the same effect as one single call.
         * Although multiple identical calls using the same client request token produce the same
         * result on the server (no side effects), the responses to the calls might not be the
         * same. If the ReturnConsumedCapacity> parameter is set, then the initial
         * TransactWriteItems call returns the amount of write capacity units
         * consumed in making the changes. Subsequent TransactWriteItems calls with
         * the same client token return the number of read capacity units consumed in reading the
         * item.
         * A client request token is valid for 10 minutes after the first request that uses it is
         * completed. After 10 minutes, any request with the same client token is treated as a new
         * request. Do not resubmit the same request with the same client token for more than 10
         * minutes, or the result might not be idempotent.
         * If you submit a request with the same client token but a change in other parameters
         * within the 10-minute idempotency window, DynamoDB returns an
         * IdempotentParameterMismatch exception.
         */
        var clientRequestToken: String?
        /**
         * Determines the level of detail about provisioned throughput consumption that is returned in the response:
         * INDEXES - The response includes the aggregate ConsumedCapacity for the operation, together with ConsumedCapacity for each table and secondary index that was accessed.
         * Note that some operations, such as GetItem and BatchGetItem, do not access any indexes at all.  In these cases, specifying INDEXES will only return ConsumedCapacity information for table(s).
         * TOTAL - The response includes only the aggregate ConsumedCapacity for the operation.
         * NONE - No ConsumedCapacity details are included in the response.
         */
        var returnConsumedCapacity: ReturnConsumedCapacity?
        /**
         * Determines whether item collection metrics are returned. If set to
         * SIZE, the response includes statistics about item collections (if any), that
         * were modified during the operation and are returned in the response.
         * If set to NONE (the default), no statistics are returned.
         */
        var returnItemCollectionMetrics: ReturnItemCollectionMetrics?
        /**
         * An ordered array of up to 25 TransactWriteItem objects, each of which
         * contains a ConditionCheck, Put, Update, or
         * Delete object. These can operate on items in different tables, but the
         * tables must reside in the same AWS account and Region, and no two of them can operate on
         * the same item.
         */
        var transactItems: List<TransactWriteItem>?

        fun build(): TransactWriteItemsRequest
    }

    private class BuilderImpl() : FluentBuilder, DslBuilder {
        override var clientRequestToken: String? = null
        override var returnConsumedCapacity: ReturnConsumedCapacity? = null
        override var returnItemCollectionMetrics: ReturnItemCollectionMetrics? = null
        override var transactItems: List<TransactWriteItem>? = null

        constructor(x: TransactWriteItemsRequest) : this() {
            this.clientRequestToken = x.clientRequestToken
            this.returnConsumedCapacity = x.returnConsumedCapacity
            this.returnItemCollectionMetrics = x.returnItemCollectionMetrics
            this.transactItems = x.transactItems
        }

        override fun build(): TransactWriteItemsRequest = TransactWriteItemsRequest(this)
        override fun clientRequestToken(clientRequestToken: String): FluentBuilder = apply { this.clientRequestToken = clientRequestToken }
        override fun returnConsumedCapacity(returnConsumedCapacity: ReturnConsumedCapacity): FluentBuilder = apply { this.returnConsumedCapacity = returnConsumedCapacity }
        override fun returnItemCollectionMetrics(returnItemCollectionMetrics: ReturnItemCollectionMetrics): FluentBuilder = apply { this.returnItemCollectionMetrics = returnItemCollectionMetrics }
        override fun transactItems(transactItems: List<TransactWriteItem>): FluentBuilder = apply { this.transactItems = transactItems }
    }
}
