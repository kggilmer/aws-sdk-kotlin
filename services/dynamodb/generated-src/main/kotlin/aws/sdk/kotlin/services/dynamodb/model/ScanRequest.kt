// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package aws.sdk.kotlin.services.dynamodb.model



/**
 * Represents the input of a Scan operation.
 */
class ScanRequest private constructor(builder: BuilderImpl) {
    /**
     * This is a legacy parameter.  Use ProjectionExpression instead.  For more information, see
     * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html">AttributesToGet in the Amazon DynamoDB Developer Guide.
     */
    val attributesToGet: List<String>? = builder.attributesToGet
    /**
     * This is a legacy parameter.  Use FilterExpression instead.   For more information, see
     * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator in the Amazon DynamoDB Developer Guide.
     */
    val conditionalOperator: ConditionalOperator? = builder.conditionalOperator
    /**
     * A Boolean value that determines the read consistency model during the scan:
     * If ConsistentRead is false, then the data returned from
     * Scan might not contain the results from other recently
     * completed write operations (PutItem, UpdateItem, or
     * DeleteItem).
     * If ConsistentRead is true, then all of the write operations that completed before the Scan began are guaranteed to be contained in the Scan response.
     * The default setting for ConsistentRead is false.
     * The ConsistentRead parameter is not supported on global secondary indexes. If you scan a global secondary index with ConsistentRead set to true, you will receive a ValidationException.
     */
    val consistentRead: Boolean? = builder.consistentRead
    /**
     * The primary key of the first item that this operation will evaluate. Use the value that was returned for LastEvaluatedKey in the previous operation.
     * The data type for ExclusiveStartKey must be String, Number or Binary. No set data types are allowed.
     * In a parallel scan, a
     * Scan request that includes ExclusiveStartKey must specify the same segment
     * whose previous Scan returned the corresponding value of LastEvaluatedKey.
     */
    val exclusiveStartKey: Map<String, AttributeValue>? = builder.exclusiveStartKey
    /**
     * One or more substitution tokens for attribute names in an expression. The following are some use cases for using ExpressionAttributeNames:
     * To access an attribute whose name conflicts with a DynamoDB reserved word.
     * To create a placeholder for repeating occurrences of an attribute name in an expression.
     * To prevent special characters in an attribute name from being misinterpreted in an expression.
     * Use the # character in an expression to dereference an attribute name. For example, consider the following attribute name:
     * Percentile
     * The name of this attribute conflicts with a reserved word, so it cannot be used directly in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words in the Amazon DynamoDB Developer Guide). To work around this, you could specify the following for ExpressionAttributeNames:
     * {"#P":"Percentile"}
     * You could then use this substitution in an expression, as in this example:
     * #P = :val
     * Tokens that begin with the : character are expression attribute values, which are placeholders for the actual value at runtime.
     * For more information on expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes in the Amazon DynamoDB Developer
     * Guide.
     */
    val expressionAttributeNames: Map<String, String>? = builder.expressionAttributeNames
    /**
     * One or more values that can be substituted in an expression.
     * Use the : (colon) character in an expression to
     * dereference an attribute value. For example, suppose that you wanted to check whether
     * the value of the ProductStatus attribute was one of the following:
     * Available | Backordered | Discontinued
     * You would first need to specify ExpressionAttributeValues as follows:
     * { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"} }
     * You could then use these values in an expression, such as this:
     * ProductStatus IN (:avail, :back, :disc)
     * For more information on expression attribute values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition Expressions in the Amazon DynamoDB Developer
     * Guide.
     */
    val expressionAttributeValues: Map<String, AttributeValue>? = builder.expressionAttributeValues
    /**
     * A string that contains conditions that DynamoDB applies after the Scan operation, but
     * before the data is returned to you. Items that do not satisfy the FilterExpression
     * criteria are not returned.
     * A FilterExpression is applied after the items have already been read; the process of
     * filtering does not consume any additional read capacity units.
     * For more information, see
     * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#FilteringResults">Filter Expressions in the Amazon DynamoDB Developer Guide.
     */
    val filterExpression: String? = builder.filterExpression
    /**
     * The name of a secondary index to scan. This index can be any local secondary index or global secondary index.  Note that if you use the IndexName parameter, you must also provide TableName.
     */
    val indexName: String? = builder.indexName
    /**
     * The maximum number of items to evaluate (not necessarily the number of matching items).
     * If DynamoDB processes the number of items up to the limit while processing the results,
     * it stops the operation and returns the matching values up to that point, and a key in
     * LastEvaluatedKey to apply in a subsequent operation, so that you can
     * pick up where you left off. Also, if the processed dataset size exceeds 1 MB before
     * DynamoDB reaches this limit, it stops the operation and returns the matching values up
     * to the limit, and a key in LastEvaluatedKey to apply in a subsequent
     * operation to continue the operation. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html">Working with Queries in the Amazon DynamoDB Developer
     * Guide.
     */
    val limit: Int? = builder.limit
    /**
     * A string that identifies one or more attributes to retrieve from the specified table or index. These attributes can include scalars, sets, or elements of a JSON document. The attributes in the expression must be separated by commas.
     * If no attribute names are specified, then all attributes will be returned. If any of the requested attributes are not found, they will not appear in the result.
     * For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes in the Amazon DynamoDB Developer
     * Guide.
     */
    val projectionExpression: String? = builder.projectionExpression
    /**
     * Determines the level of detail about provisioned throughput consumption that is returned in the response:
     * INDEXES - The response includes the aggregate ConsumedCapacity for the operation, together with ConsumedCapacity for each table and secondary index that was accessed.
     * Note that some operations, such as GetItem and BatchGetItem, do not access any indexes at all.  In these cases, specifying INDEXES will only return ConsumedCapacity information for table(s).
     * TOTAL - The response includes only the aggregate ConsumedCapacity for the operation.
     * NONE - No ConsumedCapacity details are included in the response.
     */
    val returnConsumedCapacity: ReturnConsumedCapacity? = builder.returnConsumedCapacity
    /**
     * This is a legacy parameter.  Use FilterExpression instead.   For more information, see
     * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ScanFilter.html">ScanFilter in the Amazon DynamoDB Developer Guide.
     */
    val scanFilter: Map<String, Condition>? = builder.scanFilter
    /**
     * For a parallel Scan request, Segment identifies an individual segment to be
     * scanned by an application worker.
     * Segment IDs are zero-based, so the first segment is always 0. For example, if you want to
     * use four application threads to scan a table or an index, then the first thread specifies a Segment value
     * of 0, the second thread specifies 1, and so on.
     * The value of LastEvaluatedKey returned from a parallel Scan request must be
     * used as ExclusiveStartKey with the same segment ID in a subsequent Scan
     * operation.
     * The value for Segment must be greater than or equal to 0, and less than the value
     * provided for TotalSegments.
     * If you provide Segment, you must also provide TotalSegments.
     */
    val segment: Int? = builder.segment
    /**
     * The attributes to be returned in the
     * result. You can retrieve all item attributes, specific item attributes, the count of
     * matching items, or in the case of an index, some or all of the attributes projected into
     * the index.
     * ALL_ATTRIBUTES - Returns all of the item attributes from the
     * specified table or index. If you query a local secondary index, then for each
     * matching item in the index, DynamoDB fetches the entire item from the parent
     * table. If the index is configured to project all item attributes, then all of
     * the data can be obtained from the local secondary index, and no fetching is
     * required.
     * ALL_PROJECTED_ATTRIBUTES - Allowed only when querying an index.
     * Retrieves all attributes that have been projected into the index. If the
     * index is configured to project all attributes, this return value is
     * equivalent to specifying ALL_ATTRIBUTES.
     * COUNT - Returns the number of matching items, rather than the
     * matching items themselves.
     * SPECIFIC_ATTRIBUTES - Returns only the attributes listed in
     * AttributesToGet. This return value is equivalent to
     * specifying AttributesToGet without specifying any value
     * for Select.
     * If you query or scan a local secondary index and request only attributes that
     * are projected into that index, the operation reads only the index and not the
     * table. If any of the requested attributes are not projected into the local
     * secondary index, DynamoDB fetches each of these attributes from the parent
     * table. This extra fetching incurs additional throughput cost and latency.
     * If you query or scan a global secondary index, you can only request
     * attributes that are projected into the index. Global secondary index queries
     * cannot fetch attributes from the parent table.
     * If neither Select nor AttributesToGet
     * are specified, DynamoDB defaults to ALL_ATTRIBUTES when accessing a
     * table, and ALL_PROJECTED_ATTRIBUTES when accessing an index. You cannot
     * use both Select and AttributesToGet
     * together in a single request, unless the value for Select is
     * SPECIFIC_ATTRIBUTES. (This usage is equivalent to specifying
     * AttributesToGet without any value for
     * Select.)
     * If you use the ProjectionExpression parameter, then
     * the value for Select can only be
     * SPECIFIC_ATTRIBUTES. Any other value for
     * Select will return an error.
     */
    val select: Select? = builder.select
    /**
     * The name of the table containing the requested items; or, if you provide
     * IndexName, the name of the table to which that index belongs.
     */
    val tableName: String? = builder.tableName
    /**
     * For a parallel Scan request, TotalSegments represents the total number of
     * segments into which the Scan operation will be divided. The value of
     * TotalSegments corresponds to the number of application workers that will perform the
     * parallel scan. For example, if you want to use four application threads to scan a table or an index,
     * specify a TotalSegments value of 4.
     * The value for TotalSegments must be greater than or equal to 1, and less than or equal
     * to 1000000. If you specify a TotalSegments value of 1, the Scan operation will
     * be sequential rather than parallel.
     * If you specify TotalSegments, you must also specify Segment.
     */
    val totalSegments: Int? = builder.totalSegments

    companion object {
        @JvmStatic
        fun fluentBuilder(): FluentBuilder = BuilderImpl()

        internal fun builder(): DslBuilder = BuilderImpl()

        operator fun invoke(block: DslBuilder.() -> kotlin.Unit): ScanRequest = BuilderImpl().apply(block).build()

    }

    override fun toString(): kotlin.String = buildString {
        append("ScanRequest(")
        append("attributesToGet=$attributesToGet,")
        append("conditionalOperator=$conditionalOperator,")
        append("consistentRead=$consistentRead,")
        append("exclusiveStartKey=$exclusiveStartKey,")
        append("expressionAttributeNames=$expressionAttributeNames,")
        append("expressionAttributeValues=$expressionAttributeValues,")
        append("filterExpression=$filterExpression,")
        append("indexName=$indexName,")
        append("limit=$limit,")
        append("projectionExpression=$projectionExpression,")
        append("returnConsumedCapacity=$returnConsumedCapacity,")
        append("scanFilter=$scanFilter,")
        append("segment=$segment,")
        append("select=$select,")
        append("tableName=$tableName,")
        append("totalSegments=$totalSegments)")
    }

    override fun hashCode(): kotlin.Int {
        var result = attributesToGet?.hashCode() ?: 0
        result = 31 * result + (conditionalOperator?.hashCode() ?: 0)
        result = 31 * result + (consistentRead?.hashCode() ?: 0)
        result = 31 * result + (exclusiveStartKey?.hashCode() ?: 0)
        result = 31 * result + (expressionAttributeNames?.hashCode() ?: 0)
        result = 31 * result + (expressionAttributeValues?.hashCode() ?: 0)
        result = 31 * result + (filterExpression?.hashCode() ?: 0)
        result = 31 * result + (indexName?.hashCode() ?: 0)
        result = 31 * result + (limit ?: 0)
        result = 31 * result + (projectionExpression?.hashCode() ?: 0)
        result = 31 * result + (returnConsumedCapacity?.hashCode() ?: 0)
        result = 31 * result + (scanFilter?.hashCode() ?: 0)
        result = 31 * result + (segment ?: 0)
        result = 31 * result + (select?.hashCode() ?: 0)
        result = 31 * result + (tableName?.hashCode() ?: 0)
        result = 31 * result + (totalSegments ?: 0)
        return result
    }

    override fun equals(other: kotlin.Any?): kotlin.Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ScanRequest

        if (attributesToGet != other.attributesToGet) return false
        if (conditionalOperator != other.conditionalOperator) return false
        if (consistentRead != other.consistentRead) return false
        if (exclusiveStartKey != other.exclusiveStartKey) return false
        if (expressionAttributeNames != other.expressionAttributeNames) return false
        if (expressionAttributeValues != other.expressionAttributeValues) return false
        if (filterExpression != other.filterExpression) return false
        if (indexName != other.indexName) return false
        if (limit != other.limit) return false
        if (projectionExpression != other.projectionExpression) return false
        if (returnConsumedCapacity != other.returnConsumedCapacity) return false
        if (scanFilter != other.scanFilter) return false
        if (segment != other.segment) return false
        if (select != other.select) return false
        if (tableName != other.tableName) return false
        if (totalSegments != other.totalSegments) return false

        return true
    }

    fun copy(block: DslBuilder.() -> kotlin.Unit = {}): ScanRequest = BuilderImpl(this).apply(block).build()

    interface FluentBuilder {
        fun build(): ScanRequest
        /**
         * This is a legacy parameter.  Use ProjectionExpression instead.  For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html">AttributesToGet in the Amazon DynamoDB Developer Guide.
         */
        fun attributesToGet(attributesToGet: List<String>): FluentBuilder
        /**
         * This is a legacy parameter.  Use FilterExpression instead.   For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator in the Amazon DynamoDB Developer Guide.
         */
        fun conditionalOperator(conditionalOperator: ConditionalOperator): FluentBuilder
        /**
         * A Boolean value that determines the read consistency model during the scan:
         * If ConsistentRead is false, then the data returned from
         * Scan might not contain the results from other recently
         * completed write operations (PutItem, UpdateItem, or
         * DeleteItem).
         * If ConsistentRead is true, then all of the write operations that completed before the Scan began are guaranteed to be contained in the Scan response.
         * The default setting for ConsistentRead is false.
         * The ConsistentRead parameter is not supported on global secondary indexes. If you scan a global secondary index with ConsistentRead set to true, you will receive a ValidationException.
         */
        fun consistentRead(consistentRead: Boolean): FluentBuilder
        /**
         * The primary key of the first item that this operation will evaluate. Use the value that was returned for LastEvaluatedKey in the previous operation.
         * The data type for ExclusiveStartKey must be String, Number or Binary. No set data types are allowed.
         * In a parallel scan, a
         * Scan request that includes ExclusiveStartKey must specify the same segment
         * whose previous Scan returned the corresponding value of LastEvaluatedKey.
         */
        fun exclusiveStartKey(exclusiveStartKey: Map<String, AttributeValue>): FluentBuilder
        /**
         * One or more substitution tokens for attribute names in an expression. The following are some use cases for using ExpressionAttributeNames:
         * To access an attribute whose name conflicts with a DynamoDB reserved word.
         * To create a placeholder for repeating occurrences of an attribute name in an expression.
         * To prevent special characters in an attribute name from being misinterpreted in an expression.
         * Use the # character in an expression to dereference an attribute name. For example, consider the following attribute name:
         * Percentile
         * The name of this attribute conflicts with a reserved word, so it cannot be used directly in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words in the Amazon DynamoDB Developer Guide). To work around this, you could specify the following for ExpressionAttributeNames:
         * {"#P":"Percentile"}
         * You could then use this substitution in an expression, as in this example:
         * #P = :val
         * Tokens that begin with the : character are expression attribute values, which are placeholders for the actual value at runtime.
         * For more information on expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes in the Amazon DynamoDB Developer
         * Guide.
         */
        fun expressionAttributeNames(expressionAttributeNames: Map<String, String>): FluentBuilder
        /**
         * One or more values that can be substituted in an expression.
         * Use the : (colon) character in an expression to
         * dereference an attribute value. For example, suppose that you wanted to check whether
         * the value of the ProductStatus attribute was one of the following:
         * Available | Backordered | Discontinued
         * You would first need to specify ExpressionAttributeValues as follows:
         * { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"} }
         * You could then use these values in an expression, such as this:
         * ProductStatus IN (:avail, :back, :disc)
         * For more information on expression attribute values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition Expressions in the Amazon DynamoDB Developer
         * Guide.
         */
        fun expressionAttributeValues(expressionAttributeValues: Map<String, AttributeValue>): FluentBuilder
        /**
         * A string that contains conditions that DynamoDB applies after the Scan operation, but
         * before the data is returned to you. Items that do not satisfy the FilterExpression
         * criteria are not returned.
         * A FilterExpression is applied after the items have already been read; the process of
         * filtering does not consume any additional read capacity units.
         * For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#FilteringResults">Filter Expressions in the Amazon DynamoDB Developer Guide.
         */
        fun filterExpression(filterExpression: String): FluentBuilder
        /**
         * The name of a secondary index to scan. This index can be any local secondary index or global secondary index.  Note that if you use the IndexName parameter, you must also provide TableName.
         */
        fun indexName(indexName: String): FluentBuilder
        /**
         * The maximum number of items to evaluate (not necessarily the number of matching items).
         * If DynamoDB processes the number of items up to the limit while processing the results,
         * it stops the operation and returns the matching values up to that point, and a key in
         * LastEvaluatedKey to apply in a subsequent operation, so that you can
         * pick up where you left off. Also, if the processed dataset size exceeds 1 MB before
         * DynamoDB reaches this limit, it stops the operation and returns the matching values up
         * to the limit, and a key in LastEvaluatedKey to apply in a subsequent
         * operation to continue the operation. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html">Working with Queries in the Amazon DynamoDB Developer
         * Guide.
         */
        fun limit(limit: Int): FluentBuilder
        /**
         * A string that identifies one or more attributes to retrieve from the specified table or index. These attributes can include scalars, sets, or elements of a JSON document. The attributes in the expression must be separated by commas.
         * If no attribute names are specified, then all attributes will be returned. If any of the requested attributes are not found, they will not appear in the result.
         * For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes in the Amazon DynamoDB Developer
         * Guide.
         */
        fun projectionExpression(projectionExpression: String): FluentBuilder
        /**
         * Determines the level of detail about provisioned throughput consumption that is returned in the response:
         * INDEXES - The response includes the aggregate ConsumedCapacity for the operation, together with ConsumedCapacity for each table and secondary index that was accessed.
         * Note that some operations, such as GetItem and BatchGetItem, do not access any indexes at all.  In these cases, specifying INDEXES will only return ConsumedCapacity information for table(s).
         * TOTAL - The response includes only the aggregate ConsumedCapacity for the operation.
         * NONE - No ConsumedCapacity details are included in the response.
         */
        fun returnConsumedCapacity(returnConsumedCapacity: ReturnConsumedCapacity): FluentBuilder
        /**
         * This is a legacy parameter.  Use FilterExpression instead.   For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ScanFilter.html">ScanFilter in the Amazon DynamoDB Developer Guide.
         */
        fun scanFilter(scanFilter: Map<String, Condition>): FluentBuilder
        /**
         * For a parallel Scan request, Segment identifies an individual segment to be
         * scanned by an application worker.
         * Segment IDs are zero-based, so the first segment is always 0. For example, if you want to
         * use four application threads to scan a table or an index, then the first thread specifies a Segment value
         * of 0, the second thread specifies 1, and so on.
         * The value of LastEvaluatedKey returned from a parallel Scan request must be
         * used as ExclusiveStartKey with the same segment ID in a subsequent Scan
         * operation.
         * The value for Segment must be greater than or equal to 0, and less than the value
         * provided for TotalSegments.
         * If you provide Segment, you must also provide TotalSegments.
         */
        fun segment(segment: Int): FluentBuilder
        /**
         * The attributes to be returned in the
         * result. You can retrieve all item attributes, specific item attributes, the count of
         * matching items, or in the case of an index, some or all of the attributes projected into
         * the index.
         * ALL_ATTRIBUTES - Returns all of the item attributes from the
         * specified table or index. If you query a local secondary index, then for each
         * matching item in the index, DynamoDB fetches the entire item from the parent
         * table. If the index is configured to project all item attributes, then all of
         * the data can be obtained from the local secondary index, and no fetching is
         * required.
         * ALL_PROJECTED_ATTRIBUTES - Allowed only when querying an index.
         * Retrieves all attributes that have been projected into the index. If the
         * index is configured to project all attributes, this return value is
         * equivalent to specifying ALL_ATTRIBUTES.
         * COUNT - Returns the number of matching items, rather than the
         * matching items themselves.
         * SPECIFIC_ATTRIBUTES - Returns only the attributes listed in
         * AttributesToGet. This return value is equivalent to
         * specifying AttributesToGet without specifying any value
         * for Select.
         * If you query or scan a local secondary index and request only attributes that
         * are projected into that index, the operation reads only the index and not the
         * table. If any of the requested attributes are not projected into the local
         * secondary index, DynamoDB fetches each of these attributes from the parent
         * table. This extra fetching incurs additional throughput cost and latency.
         * If you query or scan a global secondary index, you can only request
         * attributes that are projected into the index. Global secondary index queries
         * cannot fetch attributes from the parent table.
         * If neither Select nor AttributesToGet
         * are specified, DynamoDB defaults to ALL_ATTRIBUTES when accessing a
         * table, and ALL_PROJECTED_ATTRIBUTES when accessing an index. You cannot
         * use both Select and AttributesToGet
         * together in a single request, unless the value for Select is
         * SPECIFIC_ATTRIBUTES. (This usage is equivalent to specifying
         * AttributesToGet without any value for
         * Select.)
         * If you use the ProjectionExpression parameter, then
         * the value for Select can only be
         * SPECIFIC_ATTRIBUTES. Any other value for
         * Select will return an error.
         */
        fun select(select: Select): FluentBuilder
        /**
         * The name of the table containing the requested items; or, if you provide
         * IndexName, the name of the table to which that index belongs.
         */
        fun tableName(tableName: String): FluentBuilder
        /**
         * For a parallel Scan request, TotalSegments represents the total number of
         * segments into which the Scan operation will be divided. The value of
         * TotalSegments corresponds to the number of application workers that will perform the
         * parallel scan. For example, if you want to use four application threads to scan a table or an index,
         * specify a TotalSegments value of 4.
         * The value for TotalSegments must be greater than or equal to 1, and less than or equal
         * to 1000000. If you specify a TotalSegments value of 1, the Scan operation will
         * be sequential rather than parallel.
         * If you specify TotalSegments, you must also specify Segment.
         */
        fun totalSegments(totalSegments: Int): FluentBuilder
    }

    interface DslBuilder {
        /**
         * This is a legacy parameter.  Use ProjectionExpression instead.  For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html">AttributesToGet in the Amazon DynamoDB Developer Guide.
         */
        var attributesToGet: List<String>?
        /**
         * This is a legacy parameter.  Use FilterExpression instead.   For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator in the Amazon DynamoDB Developer Guide.
         */
        var conditionalOperator: ConditionalOperator?
        /**
         * A Boolean value that determines the read consistency model during the scan:
         * If ConsistentRead is false, then the data returned from
         * Scan might not contain the results from other recently
         * completed write operations (PutItem, UpdateItem, or
         * DeleteItem).
         * If ConsistentRead is true, then all of the write operations that completed before the Scan began are guaranteed to be contained in the Scan response.
         * The default setting for ConsistentRead is false.
         * The ConsistentRead parameter is not supported on global secondary indexes. If you scan a global secondary index with ConsistentRead set to true, you will receive a ValidationException.
         */
        var consistentRead: Boolean?
        /**
         * The primary key of the first item that this operation will evaluate. Use the value that was returned for LastEvaluatedKey in the previous operation.
         * The data type for ExclusiveStartKey must be String, Number or Binary. No set data types are allowed.
         * In a parallel scan, a
         * Scan request that includes ExclusiveStartKey must specify the same segment
         * whose previous Scan returned the corresponding value of LastEvaluatedKey.
         */
        var exclusiveStartKey: Map<String, AttributeValue>?
        /**
         * One or more substitution tokens for attribute names in an expression. The following are some use cases for using ExpressionAttributeNames:
         * To access an attribute whose name conflicts with a DynamoDB reserved word.
         * To create a placeholder for repeating occurrences of an attribute name in an expression.
         * To prevent special characters in an attribute name from being misinterpreted in an expression.
         * Use the # character in an expression to dereference an attribute name. For example, consider the following attribute name:
         * Percentile
         * The name of this attribute conflicts with a reserved word, so it cannot be used directly in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words in the Amazon DynamoDB Developer Guide). To work around this, you could specify the following for ExpressionAttributeNames:
         * {"#P":"Percentile"}
         * You could then use this substitution in an expression, as in this example:
         * #P = :val
         * Tokens that begin with the : character are expression attribute values, which are placeholders for the actual value at runtime.
         * For more information on expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes in the Amazon DynamoDB Developer
         * Guide.
         */
        var expressionAttributeNames: Map<String, String>?
        /**
         * One or more values that can be substituted in an expression.
         * Use the : (colon) character in an expression to
         * dereference an attribute value. For example, suppose that you wanted to check whether
         * the value of the ProductStatus attribute was one of the following:
         * Available | Backordered | Discontinued
         * You would first need to specify ExpressionAttributeValues as follows:
         * { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"} }
         * You could then use these values in an expression, such as this:
         * ProductStatus IN (:avail, :back, :disc)
         * For more information on expression attribute values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition Expressions in the Amazon DynamoDB Developer
         * Guide.
         */
        var expressionAttributeValues: Map<String, AttributeValue>?
        /**
         * A string that contains conditions that DynamoDB applies after the Scan operation, but
         * before the data is returned to you. Items that do not satisfy the FilterExpression
         * criteria are not returned.
         * A FilterExpression is applied after the items have already been read; the process of
         * filtering does not consume any additional read capacity units.
         * For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#FilteringResults">Filter Expressions in the Amazon DynamoDB Developer Guide.
         */
        var filterExpression: String?
        /**
         * The name of a secondary index to scan. This index can be any local secondary index or global secondary index.  Note that if you use the IndexName parameter, you must also provide TableName.
         */
        var indexName: String?
        /**
         * The maximum number of items to evaluate (not necessarily the number of matching items).
         * If DynamoDB processes the number of items up to the limit while processing the results,
         * it stops the operation and returns the matching values up to that point, and a key in
         * LastEvaluatedKey to apply in a subsequent operation, so that you can
         * pick up where you left off. Also, if the processed dataset size exceeds 1 MB before
         * DynamoDB reaches this limit, it stops the operation and returns the matching values up
         * to the limit, and a key in LastEvaluatedKey to apply in a subsequent
         * operation to continue the operation. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html">Working with Queries in the Amazon DynamoDB Developer
         * Guide.
         */
        var limit: Int?
        /**
         * A string that identifies one or more attributes to retrieve from the specified table or index. These attributes can include scalars, sets, or elements of a JSON document. The attributes in the expression must be separated by commas.
         * If no attribute names are specified, then all attributes will be returned. If any of the requested attributes are not found, they will not appear in the result.
         * For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes in the Amazon DynamoDB Developer
         * Guide.
         */
        var projectionExpression: String?
        /**
         * Determines the level of detail about provisioned throughput consumption that is returned in the response:
         * INDEXES - The response includes the aggregate ConsumedCapacity for the operation, together with ConsumedCapacity for each table and secondary index that was accessed.
         * Note that some operations, such as GetItem and BatchGetItem, do not access any indexes at all.  In these cases, specifying INDEXES will only return ConsumedCapacity information for table(s).
         * TOTAL - The response includes only the aggregate ConsumedCapacity for the operation.
         * NONE - No ConsumedCapacity details are included in the response.
         */
        var returnConsumedCapacity: ReturnConsumedCapacity?
        /**
         * This is a legacy parameter.  Use FilterExpression instead.   For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ScanFilter.html">ScanFilter in the Amazon DynamoDB Developer Guide.
         */
        var scanFilter: Map<String, Condition>?
        /**
         * For a parallel Scan request, Segment identifies an individual segment to be
         * scanned by an application worker.
         * Segment IDs are zero-based, so the first segment is always 0. For example, if you want to
         * use four application threads to scan a table or an index, then the first thread specifies a Segment value
         * of 0, the second thread specifies 1, and so on.
         * The value of LastEvaluatedKey returned from a parallel Scan request must be
         * used as ExclusiveStartKey with the same segment ID in a subsequent Scan
         * operation.
         * The value for Segment must be greater than or equal to 0, and less than the value
         * provided for TotalSegments.
         * If you provide Segment, you must also provide TotalSegments.
         */
        var segment: Int?
        /**
         * The attributes to be returned in the
         * result. You can retrieve all item attributes, specific item attributes, the count of
         * matching items, or in the case of an index, some or all of the attributes projected into
         * the index.
         * ALL_ATTRIBUTES - Returns all of the item attributes from the
         * specified table or index. If you query a local secondary index, then for each
         * matching item in the index, DynamoDB fetches the entire item from the parent
         * table. If the index is configured to project all item attributes, then all of
         * the data can be obtained from the local secondary index, and no fetching is
         * required.
         * ALL_PROJECTED_ATTRIBUTES - Allowed only when querying an index.
         * Retrieves all attributes that have been projected into the index. If the
         * index is configured to project all attributes, this return value is
         * equivalent to specifying ALL_ATTRIBUTES.
         * COUNT - Returns the number of matching items, rather than the
         * matching items themselves.
         * SPECIFIC_ATTRIBUTES - Returns only the attributes listed in
         * AttributesToGet. This return value is equivalent to
         * specifying AttributesToGet without specifying any value
         * for Select.
         * If you query or scan a local secondary index and request only attributes that
         * are projected into that index, the operation reads only the index and not the
         * table. If any of the requested attributes are not projected into the local
         * secondary index, DynamoDB fetches each of these attributes from the parent
         * table. This extra fetching incurs additional throughput cost and latency.
         * If you query or scan a global secondary index, you can only request
         * attributes that are projected into the index. Global secondary index queries
         * cannot fetch attributes from the parent table.
         * If neither Select nor AttributesToGet
         * are specified, DynamoDB defaults to ALL_ATTRIBUTES when accessing a
         * table, and ALL_PROJECTED_ATTRIBUTES when accessing an index. You cannot
         * use both Select and AttributesToGet
         * together in a single request, unless the value for Select is
         * SPECIFIC_ATTRIBUTES. (This usage is equivalent to specifying
         * AttributesToGet without any value for
         * Select.)
         * If you use the ProjectionExpression parameter, then
         * the value for Select can only be
         * SPECIFIC_ATTRIBUTES. Any other value for
         * Select will return an error.
         */
        var select: Select?
        /**
         * The name of the table containing the requested items; or, if you provide
         * IndexName, the name of the table to which that index belongs.
         */
        var tableName: String?
        /**
         * For a parallel Scan request, TotalSegments represents the total number of
         * segments into which the Scan operation will be divided. The value of
         * TotalSegments corresponds to the number of application workers that will perform the
         * parallel scan. For example, if you want to use four application threads to scan a table or an index,
         * specify a TotalSegments value of 4.
         * The value for TotalSegments must be greater than or equal to 1, and less than or equal
         * to 1000000. If you specify a TotalSegments value of 1, the Scan operation will
         * be sequential rather than parallel.
         * If you specify TotalSegments, you must also specify Segment.
         */
        var totalSegments: Int?

        fun build(): ScanRequest
    }

    private class BuilderImpl() : FluentBuilder, DslBuilder {
        override var attributesToGet: List<String>? = null
        override var conditionalOperator: ConditionalOperator? = null
        override var consistentRead: Boolean? = null
        override var exclusiveStartKey: Map<String, AttributeValue>? = null
        override var expressionAttributeNames: Map<String, String>? = null
        override var expressionAttributeValues: Map<String, AttributeValue>? = null
        override var filterExpression: String? = null
        override var indexName: String? = null
        override var limit: Int? = null
        override var projectionExpression: String? = null
        override var returnConsumedCapacity: ReturnConsumedCapacity? = null
        override var scanFilter: Map<String, Condition>? = null
        override var segment: Int? = null
        override var select: Select? = null
        override var tableName: String? = null
        override var totalSegments: Int? = null

        constructor(x: ScanRequest) : this() {
            this.attributesToGet = x.attributesToGet
            this.conditionalOperator = x.conditionalOperator
            this.consistentRead = x.consistentRead
            this.exclusiveStartKey = x.exclusiveStartKey
            this.expressionAttributeNames = x.expressionAttributeNames
            this.expressionAttributeValues = x.expressionAttributeValues
            this.filterExpression = x.filterExpression
            this.indexName = x.indexName
            this.limit = x.limit
            this.projectionExpression = x.projectionExpression
            this.returnConsumedCapacity = x.returnConsumedCapacity
            this.scanFilter = x.scanFilter
            this.segment = x.segment
            this.select = x.select
            this.tableName = x.tableName
            this.totalSegments = x.totalSegments
        }

        override fun build(): ScanRequest = ScanRequest(this)
        override fun attributesToGet(attributesToGet: List<String>): FluentBuilder = apply { this.attributesToGet = attributesToGet }
        override fun conditionalOperator(conditionalOperator: ConditionalOperator): FluentBuilder = apply { this.conditionalOperator = conditionalOperator }
        override fun consistentRead(consistentRead: Boolean): FluentBuilder = apply { this.consistentRead = consistentRead }
        override fun exclusiveStartKey(exclusiveStartKey: Map<String, AttributeValue>): FluentBuilder = apply { this.exclusiveStartKey = exclusiveStartKey }
        override fun expressionAttributeNames(expressionAttributeNames: Map<String, String>): FluentBuilder = apply { this.expressionAttributeNames = expressionAttributeNames }
        override fun expressionAttributeValues(expressionAttributeValues: Map<String, AttributeValue>): FluentBuilder = apply { this.expressionAttributeValues = expressionAttributeValues }
        override fun filterExpression(filterExpression: String): FluentBuilder = apply { this.filterExpression = filterExpression }
        override fun indexName(indexName: String): FluentBuilder = apply { this.indexName = indexName }
        override fun limit(limit: Int): FluentBuilder = apply { this.limit = limit }
        override fun projectionExpression(projectionExpression: String): FluentBuilder = apply { this.projectionExpression = projectionExpression }
        override fun returnConsumedCapacity(returnConsumedCapacity: ReturnConsumedCapacity): FluentBuilder = apply { this.returnConsumedCapacity = returnConsumedCapacity }
        override fun scanFilter(scanFilter: Map<String, Condition>): FluentBuilder = apply { this.scanFilter = scanFilter }
        override fun segment(segment: Int): FluentBuilder = apply { this.segment = segment }
        override fun select(select: Select): FluentBuilder = apply { this.select = select }
        override fun tableName(tableName: String): FluentBuilder = apply { this.tableName = tableName }
        override fun totalSegments(totalSegments: Int): FluentBuilder = apply { this.totalSegments = totalSegments }
    }
}
