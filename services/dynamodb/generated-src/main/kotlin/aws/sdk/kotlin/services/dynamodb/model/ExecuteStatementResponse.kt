// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package aws.sdk.kotlin.services.dynamodb.model



class ExecuteStatementResponse private constructor(builder: BuilderImpl) {
    /**
     * If a read operation was used, this property will contain the result of the reade operation; a map of attribute names and their values. For the write operations this value will be empty.
     */
    val items: List<Map<String, AttributeValue>>? = builder.items
    /**
     * If the response of a read request exceeds the response payload limit DynamoDB will set this value in the response. If set, you can use that this value in the subsequent request to get the remaining results.
     */
    val nextToken: String? = builder.nextToken

    companion object {
        @JvmStatic
        fun fluentBuilder(): FluentBuilder = BuilderImpl()

        internal fun builder(): DslBuilder = BuilderImpl()

        operator fun invoke(block: DslBuilder.() -> kotlin.Unit): ExecuteStatementResponse = BuilderImpl().apply(block).build()

    }

    override fun toString(): kotlin.String = buildString {
        append("ExecuteStatementResponse(")
        append("items=$items,")
        append("nextToken=$nextToken)")
    }

    override fun hashCode(): kotlin.Int {
        var result = items?.hashCode() ?: 0
        result = 31 * result + (nextToken?.hashCode() ?: 0)
        return result
    }

    override fun equals(other: kotlin.Any?): kotlin.Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ExecuteStatementResponse

        if (items != other.items) return false
        if (nextToken != other.nextToken) return false

        return true
    }

    fun copy(block: DslBuilder.() -> kotlin.Unit = {}): ExecuteStatementResponse = BuilderImpl(this).apply(block).build()

    interface FluentBuilder {
        fun build(): ExecuteStatementResponse
        /**
         * If a read operation was used, this property will contain the result of the reade operation; a map of attribute names and their values. For the write operations this value will be empty.
         */
        fun items(items: List<Map<String, AttributeValue>>): FluentBuilder
        /**
         * If the response of a read request exceeds the response payload limit DynamoDB will set this value in the response. If set, you can use that this value in the subsequent request to get the remaining results.
         */
        fun nextToken(nextToken: String): FluentBuilder
    }

    interface DslBuilder {
        /**
         * If a read operation was used, this property will contain the result of the reade operation; a map of attribute names and their values. For the write operations this value will be empty.
         */
        var items: List<Map<String, AttributeValue>>?
        /**
         * If the response of a read request exceeds the response payload limit DynamoDB will set this value in the response. If set, you can use that this value in the subsequent request to get the remaining results.
         */
        var nextToken: String?

        fun build(): ExecuteStatementResponse
    }

    private class BuilderImpl() : FluentBuilder, DslBuilder {
        override var items: List<Map<String, AttributeValue>>? = null
        override var nextToken: String? = null

        constructor(x: ExecuteStatementResponse) : this() {
            this.items = x.items
            this.nextToken = x.nextToken
        }

        override fun build(): ExecuteStatementResponse = ExecuteStatementResponse(this)
        override fun items(items: List<Map<String, AttributeValue>>): FluentBuilder = apply { this.items = items }
        override fun nextToken(nextToken: String): FluentBuilder = apply { this.nextToken = nextToken }
    }
}
