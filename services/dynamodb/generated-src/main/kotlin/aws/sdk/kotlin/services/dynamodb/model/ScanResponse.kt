// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package aws.sdk.kotlin.services.dynamodb.model



/**
 * Represents the output of a Scan operation.
 */
class ScanResponse private constructor(builder: BuilderImpl) {
    /**
     * The capacity units consumed by the Scan operation. The data returned includes the total
     * provisioned throughput consumed, along with statistics for the table and any indexes involved
     * in the operation. ConsumedCapacity is only returned if the ReturnConsumedCapacity parameter was specified.
     * For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned
     * Throughput in the Amazon DynamoDB Developer Guide.
     */
    val consumedCapacity: ConsumedCapacity? = builder.consumedCapacity
    /**
     * The number of items in the response.
     * If you set ScanFilter in the request, then Count is the number of items
     * returned after the filter was applied, and ScannedCount is the number of matching items
     * before the filter was applied.
     * If you did not use a filter in the request, then Count is the same as
     * ScannedCount.
     */
    val count: Int = builder.count
    /**
     * An array of item attributes that match the scan criteria. Each element in this array consists of an attribute name and the value for that attribute.
     */
    val items: List<Map<String, AttributeValue>>? = builder.items
    /**
     * The primary key of the item where the operation stopped, inclusive of the previous
     * result set. Use this value to start a new operation, excluding this value in the new
     * request.
     * If LastEvaluatedKey is empty, then the "last page" of results
     * has been processed and there is no more data to be retrieved.
     * If LastEvaluatedKey is not empty, it does not necessarily mean
     * that there is more data in the result set. The only way to know when you have reached
     * the end of the result set is when LastEvaluatedKey is
     * empty.
     */
    val lastEvaluatedKey: Map<String, AttributeValue>? = builder.lastEvaluatedKey
    /**
     * The number of items evaluated, before any ScanFilter is applied. A high
     * ScannedCount value with few, or no, Count results indicates an inefficient
     * Scan operation. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Count">Count and ScannedCount in the
     * Amazon DynamoDB Developer Guide.
     * If you did not use a filter in the request, then ScannedCount is the same as
     * Count.
     */
    val scannedCount: Int = builder.scannedCount

    companion object {
        @JvmStatic
        fun fluentBuilder(): FluentBuilder = BuilderImpl()

        internal fun builder(): DslBuilder = BuilderImpl()

        operator fun invoke(block: DslBuilder.() -> kotlin.Unit): ScanResponse = BuilderImpl().apply(block).build()

    }

    override fun toString(): kotlin.String = buildString {
        append("ScanResponse(")
        append("consumedCapacity=$consumedCapacity,")
        append("count=$count,")
        append("items=$items,")
        append("lastEvaluatedKey=$lastEvaluatedKey,")
        append("scannedCount=$scannedCount)")
    }

    override fun hashCode(): kotlin.Int {
        var result = consumedCapacity?.hashCode() ?: 0
        result = 31 * result + (count)
        result = 31 * result + (items?.hashCode() ?: 0)
        result = 31 * result + (lastEvaluatedKey?.hashCode() ?: 0)
        result = 31 * result + (scannedCount)
        return result
    }

    override fun equals(other: kotlin.Any?): kotlin.Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ScanResponse

        if (consumedCapacity != other.consumedCapacity) return false
        if (count != other.count) return false
        if (items != other.items) return false
        if (lastEvaluatedKey != other.lastEvaluatedKey) return false
        if (scannedCount != other.scannedCount) return false

        return true
    }

    fun copy(block: DslBuilder.() -> kotlin.Unit = {}): ScanResponse = BuilderImpl(this).apply(block).build()

    interface FluentBuilder {
        fun build(): ScanResponse
        /**
         * The capacity units consumed by the Scan operation. The data returned includes the total
         * provisioned throughput consumed, along with statistics for the table and any indexes involved
         * in the operation. ConsumedCapacity is only returned if the ReturnConsumedCapacity parameter was specified.
         * For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned
         * Throughput in the Amazon DynamoDB Developer Guide.
         */
        fun consumedCapacity(consumedCapacity: ConsumedCapacity): FluentBuilder
        /**
         * The number of items in the response.
         * If you set ScanFilter in the request, then Count is the number of items
         * returned after the filter was applied, and ScannedCount is the number of matching items
         * before the filter was applied.
         * If you did not use a filter in the request, then Count is the same as
         * ScannedCount.
         */
        fun count(count: Int): FluentBuilder
        /**
         * An array of item attributes that match the scan criteria. Each element in this array consists of an attribute name and the value for that attribute.
         */
        fun items(items: List<Map<String, AttributeValue>>): FluentBuilder
        /**
         * The primary key of the item where the operation stopped, inclusive of the previous
         * result set. Use this value to start a new operation, excluding this value in the new
         * request.
         * If LastEvaluatedKey is empty, then the "last page" of results
         * has been processed and there is no more data to be retrieved.
         * If LastEvaluatedKey is not empty, it does not necessarily mean
         * that there is more data in the result set. The only way to know when you have reached
         * the end of the result set is when LastEvaluatedKey is
         * empty.
         */
        fun lastEvaluatedKey(lastEvaluatedKey: Map<String, AttributeValue>): FluentBuilder
        /**
         * The number of items evaluated, before any ScanFilter is applied. A high
         * ScannedCount value with few, or no, Count results indicates an inefficient
         * Scan operation. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Count">Count and ScannedCount in the
         * Amazon DynamoDB Developer Guide.
         * If you did not use a filter in the request, then ScannedCount is the same as
         * Count.
         */
        fun scannedCount(scannedCount: Int): FluentBuilder
    }

    interface DslBuilder {
        /**
         * The capacity units consumed by the Scan operation. The data returned includes the total
         * provisioned throughput consumed, along with statistics for the table and any indexes involved
         * in the operation. ConsumedCapacity is only returned if the ReturnConsumedCapacity parameter was specified.
         * For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned
         * Throughput in the Amazon DynamoDB Developer Guide.
         */
        var consumedCapacity: ConsumedCapacity?
        /**
         * The number of items in the response.
         * If you set ScanFilter in the request, then Count is the number of items
         * returned after the filter was applied, and ScannedCount is the number of matching items
         * before the filter was applied.
         * If you did not use a filter in the request, then Count is the same as
         * ScannedCount.
         */
        var count: Int
        /**
         * An array of item attributes that match the scan criteria. Each element in this array consists of an attribute name and the value for that attribute.
         */
        var items: List<Map<String, AttributeValue>>?
        /**
         * The primary key of the item where the operation stopped, inclusive of the previous
         * result set. Use this value to start a new operation, excluding this value in the new
         * request.
         * If LastEvaluatedKey is empty, then the "last page" of results
         * has been processed and there is no more data to be retrieved.
         * If LastEvaluatedKey is not empty, it does not necessarily mean
         * that there is more data in the result set. The only way to know when you have reached
         * the end of the result set is when LastEvaluatedKey is
         * empty.
         */
        var lastEvaluatedKey: Map<String, AttributeValue>?
        /**
         * The number of items evaluated, before any ScanFilter is applied. A high
         * ScannedCount value with few, or no, Count results indicates an inefficient
         * Scan operation. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Count">Count and ScannedCount in the
         * Amazon DynamoDB Developer Guide.
         * If you did not use a filter in the request, then ScannedCount is the same as
         * Count.
         */
        var scannedCount: Int

        fun build(): ScanResponse
        /**
         * construct an [aws.sdk.kotlin.services.dynamodb.model.ConsumedCapacity] inside the given [block]
         */
        fun consumedCapacity(block: ConsumedCapacity.DslBuilder.() -> kotlin.Unit) {
            this.consumedCapacity = ConsumedCapacity.invoke(block)
        }
    }

    private class BuilderImpl() : FluentBuilder, DslBuilder {
        override var consumedCapacity: ConsumedCapacity? = null
        override var count: Int = 0
        override var items: List<Map<String, AttributeValue>>? = null
        override var lastEvaluatedKey: Map<String, AttributeValue>? = null
        override var scannedCount: Int = 0

        constructor(x: ScanResponse) : this() {
            this.consumedCapacity = x.consumedCapacity
            this.count = x.count
            this.items = x.items
            this.lastEvaluatedKey = x.lastEvaluatedKey
            this.scannedCount = x.scannedCount
        }

        override fun build(): ScanResponse = ScanResponse(this)
        override fun consumedCapacity(consumedCapacity: ConsumedCapacity): FluentBuilder = apply { this.consumedCapacity = consumedCapacity }
        override fun count(count: Int): FluentBuilder = apply { this.count = count }
        override fun items(items: List<Map<String, AttributeValue>>): FluentBuilder = apply { this.items = items }
        override fun lastEvaluatedKey(lastEvaluatedKey: Map<String, AttributeValue>): FluentBuilder = apply { this.lastEvaluatedKey = lastEvaluatedKey }
        override fun scannedCount(scannedCount: Int): FluentBuilder = apply { this.scannedCount = scannedCount }
    }
}
