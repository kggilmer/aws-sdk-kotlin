// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package aws.sdk.kotlin.services.dynamodb.model



/**
 * Represents the input of an UpdateItem operation.
 */
class UpdateItemRequest private constructor(builder: BuilderImpl) {
    /**
     * This is a legacy parameter.  Use UpdateExpression instead.   For more information, see
     * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributeUpdates.html">AttributeUpdates in the Amazon DynamoDB Developer Guide.
     */
    val attributeUpdates: Map<String, AttributeValueUpdate>? = builder.attributeUpdates
    /**
     * A condition that must be satisfied in order for a conditional update to succeed.
     * An expression can contain any of the following:
     * Functions: attribute_exists | attribute_not_exists | attribute_type | contains | begins_with | size
     * These function names are case-sensitive.
     * Comparison operators: = | <> |
     * < | > | <= | >= |
     * BETWEEN | IN
     * Logical operators: AND | OR | NOT
     * For more information about condition expressions, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Specifying Conditions in the Amazon DynamoDB Developer
     * Guide.
     */
    val conditionExpression: String? = builder.conditionExpression
    /**
     * This is a legacy parameter.  Use ConditionExpression instead.   For more information, see
     * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator in the Amazon DynamoDB Developer Guide.
     */
    val conditionalOperator: ConditionalOperator? = builder.conditionalOperator
    /**
     * This is a legacy parameter.  Use ConditionExpression instead.   For more information, see
     * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html">Expected in the Amazon DynamoDB Developer Guide.
     */
    val expected: Map<String, ExpectedAttributeValue>? = builder.expected
    /**
     * One or more substitution tokens for attribute names in an expression. The following are some use cases for using ExpressionAttributeNames:
     * To access an attribute whose name conflicts with a DynamoDB reserved word.
     * To create a placeholder for repeating occurrences of an attribute name in an expression.
     * To prevent special characters in an attribute name from being misinterpreted in an expression.
     * Use the # character in an expression to dereference an attribute name. For example, consider the following attribute name:
     * Percentile
     * The name of this attribute conflicts with a reserved word, so it cannot be used directly
     * in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words in the Amazon DynamoDB Developer
     * Guide.) To work around this, you could specify the following for
     * ExpressionAttributeNames:
     * {"#P":"Percentile"}
     * You could then use this substitution in an expression, as in this example:
     * #P = :val
     * Tokens that begin with the : character are expression attribute values, which are placeholders for the actual value at runtime.
     * For more information about expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes in the Amazon DynamoDB Developer
     * Guide.
     */
    val expressionAttributeNames: Map<String, String>? = builder.expressionAttributeNames
    /**
     * One or more values that can be substituted in an expression.
     * Use the : (colon) character in an expression to
     * dereference an attribute value. For example, suppose that you wanted to check whether
     * the value of the ProductStatus attribute was one of the following:
     * Available | Backordered | Discontinued
     * You would first need to specify ExpressionAttributeValues as follows:
     * { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"} }
     * You could then use these values in an expression, such as this:
     * ProductStatus IN (:avail, :back, :disc)
     * For more information on expression attribute values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition Expressions in the Amazon DynamoDB Developer
     * Guide.
     */
    val expressionAttributeValues: Map<String, AttributeValue>? = builder.expressionAttributeValues
    /**
     * The primary key of the item to be updated. Each element consists of an attribute name and a value for that attribute.
     * For the primary key, you must provide all of the attributes. For example, with a simple primary key, you only need to provide a value for the partition key. For a composite primary key, you must provide values for both the partition key and the sort key.
     */
    val key: Map<String, AttributeValue>? = builder.key
    /**
     * Determines the level of detail about provisioned throughput consumption that is returned in the response:
     * INDEXES - The response includes the aggregate ConsumedCapacity for the operation, together with ConsumedCapacity for each table and secondary index that was accessed.
     * Note that some operations, such as GetItem and BatchGetItem, do not access any indexes at all.  In these cases, specifying INDEXES will only return ConsumedCapacity information for table(s).
     * TOTAL - The response includes only the aggregate ConsumedCapacity for the operation.
     * NONE - No ConsumedCapacity details are included in the response.
     */
    val returnConsumedCapacity: ReturnConsumedCapacity? = builder.returnConsumedCapacity
    /**
     * Determines whether item collection metrics are returned.  If set to SIZE, the response includes statistics about item collections, if any, that were modified during
     * the operation are returned in the response. If set to NONE (the default), no statistics are returned.
     */
    val returnItemCollectionMetrics: ReturnItemCollectionMetrics? = builder.returnItemCollectionMetrics
    /**
     * Use ReturnValues if you want to get the item attributes as they appear
     * before or after they are updated. For UpdateItem, the valid values
     * are:
     * NONE - If ReturnValues is not specified, or if its value is
     * NONE, then nothing is returned. (This setting is the default for
     * ReturnValues.)
     * ALL_OLD - Returns all of the attributes of the item, as they appeared before the UpdateItem operation.
     * UPDATED_OLD - Returns only the updated attributes, as they appeared before the UpdateItem operation.
     * ALL_NEW - Returns all of the attributes of the item, as they appear after the UpdateItem operation.
     * UPDATED_NEW - Returns only the updated attributes, as they appear after the UpdateItem operation.
     * There is no additional cost associated with requesting a return value aside from the
     * small network and processing overhead of receiving a larger response. No read capacity
     * units are consumed.
     * The values returned are strongly consistent.
     */
    val returnValues: ReturnValue? = builder.returnValues
    /**
     * The name of the table containing the item to update.
     */
    val tableName: String? = builder.tableName
    /**
     * An expression that defines one or more attributes to be updated, the action to be
     * performed on them, and new values for them.
     * The following action values are available for UpdateExpression.
     * SET - Adds one or more attributes and values to an item. If any of
     * these attributes already exist, they are replaced by the new values. You can
     * also use SET to add or subtract from an attribute that is of type
     * Number. For example: SET myNum = myNum + :val
     * SET supports the following functions:
     * if_not_exists (path, operand) - if the item does not contain an attribute at the specified path, then if_not_exists evaluates to operand; otherwise, it evaluates to path. You can use this function to avoid overwriting an attribute that may already be present in the item.
     * list_append (operand, operand) - evaluates to a list with a new element added to it. You can append the new element to the start or the end of the list by reversing the order of the operands.
     * These function names are case-sensitive.
     * REMOVE - Removes one or more attributes from an item.
     * ADD - Adds the specified value to the item, if the attribute does not already exist. If the attribute does exist, then the behavior of
     * ADD depends on the data type of the attribute:
     * If the existing attribute is a number, and if Value is also a number, then
     * Value is mathematically added to the existing attribute. If Value is a
     * negative number, then it is subtracted from the existing attribute.
     * If you use ADD to increment or decrement a number value for an item
     * that doesn't exist before the update, DynamoDB uses 0 as the initial
     * value.
     * Similarly, if you use ADD for an existing item to increment
     * or decrement an attribute value that doesn't exist before the
     * update, DynamoDB uses 0 as the initial value. For
     * example, suppose that the item you want to update doesn't have an
     * attribute named itemcount, but you decide to
     * ADD the number 3 to this attribute
     * anyway. DynamoDB will create the itemcount attribute,
     * set its initial value to 0, and finally add
     * 3 to it. The result will be a new
     * itemcount attribute in the item, with a value of
     * 3.
     * If the existing data type is a set and if Value is also a set, then
     * Value is added to the existing set. For example, if the attribute value is the set
     * &#91;1,2&#93;, and the ADD action specified &#91;3&#93;, then
     * the final attribute value is &#91;1,2,3&#93;. An error occurs if an ADD
     * action is specified for a set attribute and the attribute type specified does not
     * match the existing set type.
     * Both sets must have the same primitive data type. For example, if the existing data
     * type is a set of strings, the Value must also be a set of strings.
     * The ADD action only supports Number and set data types. In addition,
     * ADD can only be used on top-level attributes, not nested attributes.
     * DELETE - Deletes an element from a set.
     * If a set of values is specified, then those values are subtracted from the old
     * set. For example, if the attribute value was the set &#91;a,b,c&#93; and the
     * DELETE action specifies &#91;a,c&#93;, then the final attribute value
     * is &#91;b&#93;. Specifying an empty set is an error.
     * The DELETE action only supports set data types. In addition,
     * DELETE can only be used on top-level attributes, not nested attributes.
     * You can have many actions in a single expression, such as the following: SET a=:value1,
     * b=:value2 DELETE :value3, :value4, :value5
     * For more information on update expressions, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Modifying.html">Modifying Items and Attributes in the Amazon DynamoDB Developer Guide.
     */
    val updateExpression: String? = builder.updateExpression

    companion object {
        @JvmStatic
        fun fluentBuilder(): FluentBuilder = BuilderImpl()

        internal fun builder(): DslBuilder = BuilderImpl()

        operator fun invoke(block: DslBuilder.() -> kotlin.Unit): UpdateItemRequest = BuilderImpl().apply(block).build()

    }

    override fun toString(): kotlin.String = buildString {
        append("UpdateItemRequest(")
        append("attributeUpdates=$attributeUpdates,")
        append("conditionExpression=$conditionExpression,")
        append("conditionalOperator=$conditionalOperator,")
        append("expected=$expected,")
        append("expressionAttributeNames=$expressionAttributeNames,")
        append("expressionAttributeValues=$expressionAttributeValues,")
        append("key=$key,")
        append("returnConsumedCapacity=$returnConsumedCapacity,")
        append("returnItemCollectionMetrics=$returnItemCollectionMetrics,")
        append("returnValues=$returnValues,")
        append("tableName=$tableName,")
        append("updateExpression=$updateExpression)")
    }

    override fun hashCode(): kotlin.Int {
        var result = attributeUpdates?.hashCode() ?: 0
        result = 31 * result + (conditionExpression?.hashCode() ?: 0)
        result = 31 * result + (conditionalOperator?.hashCode() ?: 0)
        result = 31 * result + (expected?.hashCode() ?: 0)
        result = 31 * result + (expressionAttributeNames?.hashCode() ?: 0)
        result = 31 * result + (expressionAttributeValues?.hashCode() ?: 0)
        result = 31 * result + (key?.hashCode() ?: 0)
        result = 31 * result + (returnConsumedCapacity?.hashCode() ?: 0)
        result = 31 * result + (returnItemCollectionMetrics?.hashCode() ?: 0)
        result = 31 * result + (returnValues?.hashCode() ?: 0)
        result = 31 * result + (tableName?.hashCode() ?: 0)
        result = 31 * result + (updateExpression?.hashCode() ?: 0)
        return result
    }

    override fun equals(other: kotlin.Any?): kotlin.Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as UpdateItemRequest

        if (attributeUpdates != other.attributeUpdates) return false
        if (conditionExpression != other.conditionExpression) return false
        if (conditionalOperator != other.conditionalOperator) return false
        if (expected != other.expected) return false
        if (expressionAttributeNames != other.expressionAttributeNames) return false
        if (expressionAttributeValues != other.expressionAttributeValues) return false
        if (key != other.key) return false
        if (returnConsumedCapacity != other.returnConsumedCapacity) return false
        if (returnItemCollectionMetrics != other.returnItemCollectionMetrics) return false
        if (returnValues != other.returnValues) return false
        if (tableName != other.tableName) return false
        if (updateExpression != other.updateExpression) return false

        return true
    }

    fun copy(block: DslBuilder.() -> kotlin.Unit = {}): UpdateItemRequest = BuilderImpl(this).apply(block).build()

    interface FluentBuilder {
        fun build(): UpdateItemRequest
        /**
         * This is a legacy parameter.  Use UpdateExpression instead.   For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributeUpdates.html">AttributeUpdates in the Amazon DynamoDB Developer Guide.
         */
        fun attributeUpdates(attributeUpdates: Map<String, AttributeValueUpdate>): FluentBuilder
        /**
         * A condition that must be satisfied in order for a conditional update to succeed.
         * An expression can contain any of the following:
         * Functions: attribute_exists | attribute_not_exists | attribute_type | contains | begins_with | size
         * These function names are case-sensitive.
         * Comparison operators: = | <> |
         * < | > | <= | >= |
         * BETWEEN | IN
         * Logical operators: AND | OR | NOT
         * For more information about condition expressions, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Specifying Conditions in the Amazon DynamoDB Developer
         * Guide.
         */
        fun conditionExpression(conditionExpression: String): FluentBuilder
        /**
         * This is a legacy parameter.  Use ConditionExpression instead.   For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator in the Amazon DynamoDB Developer Guide.
         */
        fun conditionalOperator(conditionalOperator: ConditionalOperator): FluentBuilder
        /**
         * This is a legacy parameter.  Use ConditionExpression instead.   For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html">Expected in the Amazon DynamoDB Developer Guide.
         */
        fun expected(expected: Map<String, ExpectedAttributeValue>): FluentBuilder
        /**
         * One or more substitution tokens for attribute names in an expression. The following are some use cases for using ExpressionAttributeNames:
         * To access an attribute whose name conflicts with a DynamoDB reserved word.
         * To create a placeholder for repeating occurrences of an attribute name in an expression.
         * To prevent special characters in an attribute name from being misinterpreted in an expression.
         * Use the # character in an expression to dereference an attribute name. For example, consider the following attribute name:
         * Percentile
         * The name of this attribute conflicts with a reserved word, so it cannot be used directly
         * in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words in the Amazon DynamoDB Developer
         * Guide.) To work around this, you could specify the following for
         * ExpressionAttributeNames:
         * {"#P":"Percentile"}
         * You could then use this substitution in an expression, as in this example:
         * #P = :val
         * Tokens that begin with the : character are expression attribute values, which are placeholders for the actual value at runtime.
         * For more information about expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes in the Amazon DynamoDB Developer
         * Guide.
         */
        fun expressionAttributeNames(expressionAttributeNames: Map<String, String>): FluentBuilder
        /**
         * One or more values that can be substituted in an expression.
         * Use the : (colon) character in an expression to
         * dereference an attribute value. For example, suppose that you wanted to check whether
         * the value of the ProductStatus attribute was one of the following:
         * Available | Backordered | Discontinued
         * You would first need to specify ExpressionAttributeValues as follows:
         * { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"} }
         * You could then use these values in an expression, such as this:
         * ProductStatus IN (:avail, :back, :disc)
         * For more information on expression attribute values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition Expressions in the Amazon DynamoDB Developer
         * Guide.
         */
        fun expressionAttributeValues(expressionAttributeValues: Map<String, AttributeValue>): FluentBuilder
        /**
         * The primary key of the item to be updated. Each element consists of an attribute name and a value for that attribute.
         * For the primary key, you must provide all of the attributes. For example, with a simple primary key, you only need to provide a value for the partition key. For a composite primary key, you must provide values for both the partition key and the sort key.
         */
        fun key(key: Map<String, AttributeValue>): FluentBuilder
        /**
         * Determines the level of detail about provisioned throughput consumption that is returned in the response:
         * INDEXES - The response includes the aggregate ConsumedCapacity for the operation, together with ConsumedCapacity for each table and secondary index that was accessed.
         * Note that some operations, such as GetItem and BatchGetItem, do not access any indexes at all.  In these cases, specifying INDEXES will only return ConsumedCapacity information for table(s).
         * TOTAL - The response includes only the aggregate ConsumedCapacity for the operation.
         * NONE - No ConsumedCapacity details are included in the response.
         */
        fun returnConsumedCapacity(returnConsumedCapacity: ReturnConsumedCapacity): FluentBuilder
        /**
         * Determines whether item collection metrics are returned.  If set to SIZE, the response includes statistics about item collections, if any, that were modified during
         * the operation are returned in the response. If set to NONE (the default), no statistics are returned.
         */
        fun returnItemCollectionMetrics(returnItemCollectionMetrics: ReturnItemCollectionMetrics): FluentBuilder
        /**
         * Use ReturnValues if you want to get the item attributes as they appear
         * before or after they are updated. For UpdateItem, the valid values
         * are:
         * NONE - If ReturnValues is not specified, or if its value is
         * NONE, then nothing is returned. (This setting is the default for
         * ReturnValues.)
         * ALL_OLD - Returns all of the attributes of the item, as they appeared before the UpdateItem operation.
         * UPDATED_OLD - Returns only the updated attributes, as they appeared before the UpdateItem operation.
         * ALL_NEW - Returns all of the attributes of the item, as they appear after the UpdateItem operation.
         * UPDATED_NEW - Returns only the updated attributes, as they appear after the UpdateItem operation.
         * There is no additional cost associated with requesting a return value aside from the
         * small network and processing overhead of receiving a larger response. No read capacity
         * units are consumed.
         * The values returned are strongly consistent.
         */
        fun returnValues(returnValues: ReturnValue): FluentBuilder
        /**
         * The name of the table containing the item to update.
         */
        fun tableName(tableName: String): FluentBuilder
        /**
         * An expression that defines one or more attributes to be updated, the action to be
         * performed on them, and new values for them.
         * The following action values are available for UpdateExpression.
         * SET - Adds one or more attributes and values to an item. If any of
         * these attributes already exist, they are replaced by the new values. You can
         * also use SET to add or subtract from an attribute that is of type
         * Number. For example: SET myNum = myNum + :val
         * SET supports the following functions:
         * if_not_exists (path, operand) - if the item does not contain an attribute at the specified path, then if_not_exists evaluates to operand; otherwise, it evaluates to path. You can use this function to avoid overwriting an attribute that may already be present in the item.
         * list_append (operand, operand) - evaluates to a list with a new element added to it. You can append the new element to the start or the end of the list by reversing the order of the operands.
         * These function names are case-sensitive.
         * REMOVE - Removes one or more attributes from an item.
         * ADD - Adds the specified value to the item, if the attribute does not already exist. If the attribute does exist, then the behavior of
         * ADD depends on the data type of the attribute:
         * If the existing attribute is a number, and if Value is also a number, then
         * Value is mathematically added to the existing attribute. If Value is a
         * negative number, then it is subtracted from the existing attribute.
         * If you use ADD to increment or decrement a number value for an item
         * that doesn't exist before the update, DynamoDB uses 0 as the initial
         * value.
         * Similarly, if you use ADD for an existing item to increment
         * or decrement an attribute value that doesn't exist before the
         * update, DynamoDB uses 0 as the initial value. For
         * example, suppose that the item you want to update doesn't have an
         * attribute named itemcount, but you decide to
         * ADD the number 3 to this attribute
         * anyway. DynamoDB will create the itemcount attribute,
         * set its initial value to 0, and finally add
         * 3 to it. The result will be a new
         * itemcount attribute in the item, with a value of
         * 3.
         * If the existing data type is a set and if Value is also a set, then
         * Value is added to the existing set. For example, if the attribute value is the set
         * &#91;1,2&#93;, and the ADD action specified &#91;3&#93;, then
         * the final attribute value is &#91;1,2,3&#93;. An error occurs if an ADD
         * action is specified for a set attribute and the attribute type specified does not
         * match the existing set type.
         * Both sets must have the same primitive data type. For example, if the existing data
         * type is a set of strings, the Value must also be a set of strings.
         * The ADD action only supports Number and set data types. In addition,
         * ADD can only be used on top-level attributes, not nested attributes.
         * DELETE - Deletes an element from a set.
         * If a set of values is specified, then those values are subtracted from the old
         * set. For example, if the attribute value was the set &#91;a,b,c&#93; and the
         * DELETE action specifies &#91;a,c&#93;, then the final attribute value
         * is &#91;b&#93;. Specifying an empty set is an error.
         * The DELETE action only supports set data types. In addition,
         * DELETE can only be used on top-level attributes, not nested attributes.
         * You can have many actions in a single expression, such as the following: SET a=:value1,
         * b=:value2 DELETE :value3, :value4, :value5
         * For more information on update expressions, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Modifying.html">Modifying Items and Attributes in the Amazon DynamoDB Developer Guide.
         */
        fun updateExpression(updateExpression: String): FluentBuilder
    }

    interface DslBuilder {
        /**
         * This is a legacy parameter.  Use UpdateExpression instead.   For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributeUpdates.html">AttributeUpdates in the Amazon DynamoDB Developer Guide.
         */
        var attributeUpdates: Map<String, AttributeValueUpdate>?
        /**
         * A condition that must be satisfied in order for a conditional update to succeed.
         * An expression can contain any of the following:
         * Functions: attribute_exists | attribute_not_exists | attribute_type | contains | begins_with | size
         * These function names are case-sensitive.
         * Comparison operators: = | <> |
         * < | > | <= | >= |
         * BETWEEN | IN
         * Logical operators: AND | OR | NOT
         * For more information about condition expressions, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Specifying Conditions in the Amazon DynamoDB Developer
         * Guide.
         */
        var conditionExpression: String?
        /**
         * This is a legacy parameter.  Use ConditionExpression instead.   For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html">ConditionalOperator in the Amazon DynamoDB Developer Guide.
         */
        var conditionalOperator: ConditionalOperator?
        /**
         * This is a legacy parameter.  Use ConditionExpression instead.   For more information, see
         * <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html">Expected in the Amazon DynamoDB Developer Guide.
         */
        var expected: Map<String, ExpectedAttributeValue>?
        /**
         * One or more substitution tokens for attribute names in an expression. The following are some use cases for using ExpressionAttributeNames:
         * To access an attribute whose name conflicts with a DynamoDB reserved word.
         * To create a placeholder for repeating occurrences of an attribute name in an expression.
         * To prevent special characters in an attribute name from being misinterpreted in an expression.
         * Use the # character in an expression to dereference an attribute name. For example, consider the following attribute name:
         * Percentile
         * The name of this attribute conflicts with a reserved word, so it cannot be used directly
         * in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words in the Amazon DynamoDB Developer
         * Guide.) To work around this, you could specify the following for
         * ExpressionAttributeNames:
         * {"#P":"Percentile"}
         * You could then use this substitution in an expression, as in this example:
         * #P = :val
         * Tokens that begin with the : character are expression attribute values, which are placeholders for the actual value at runtime.
         * For more information about expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Specifying Item Attributes in the Amazon DynamoDB Developer
         * Guide.
         */
        var expressionAttributeNames: Map<String, String>?
        /**
         * One or more values that can be substituted in an expression.
         * Use the : (colon) character in an expression to
         * dereference an attribute value. For example, suppose that you wanted to check whether
         * the value of the ProductStatus attribute was one of the following:
         * Available | Backordered | Discontinued
         * You would first need to specify ExpressionAttributeValues as follows:
         * { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"} }
         * You could then use these values in an expression, such as this:
         * ProductStatus IN (:avail, :back, :disc)
         * For more information on expression attribute values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html">Condition Expressions in the Amazon DynamoDB Developer
         * Guide.
         */
        var expressionAttributeValues: Map<String, AttributeValue>?
        /**
         * The primary key of the item to be updated. Each element consists of an attribute name and a value for that attribute.
         * For the primary key, you must provide all of the attributes. For example, with a simple primary key, you only need to provide a value for the partition key. For a composite primary key, you must provide values for both the partition key and the sort key.
         */
        var key: Map<String, AttributeValue>?
        /**
         * Determines the level of detail about provisioned throughput consumption that is returned in the response:
         * INDEXES - The response includes the aggregate ConsumedCapacity for the operation, together with ConsumedCapacity for each table and secondary index that was accessed.
         * Note that some operations, such as GetItem and BatchGetItem, do not access any indexes at all.  In these cases, specifying INDEXES will only return ConsumedCapacity information for table(s).
         * TOTAL - The response includes only the aggregate ConsumedCapacity for the operation.
         * NONE - No ConsumedCapacity details are included in the response.
         */
        var returnConsumedCapacity: ReturnConsumedCapacity?
        /**
         * Determines whether item collection metrics are returned.  If set to SIZE, the response includes statistics about item collections, if any, that were modified during
         * the operation are returned in the response. If set to NONE (the default), no statistics are returned.
         */
        var returnItemCollectionMetrics: ReturnItemCollectionMetrics?
        /**
         * Use ReturnValues if you want to get the item attributes as they appear
         * before or after they are updated. For UpdateItem, the valid values
         * are:
         * NONE - If ReturnValues is not specified, or if its value is
         * NONE, then nothing is returned. (This setting is the default for
         * ReturnValues.)
         * ALL_OLD - Returns all of the attributes of the item, as they appeared before the UpdateItem operation.
         * UPDATED_OLD - Returns only the updated attributes, as they appeared before the UpdateItem operation.
         * ALL_NEW - Returns all of the attributes of the item, as they appear after the UpdateItem operation.
         * UPDATED_NEW - Returns only the updated attributes, as they appear after the UpdateItem operation.
         * There is no additional cost associated with requesting a return value aside from the
         * small network and processing overhead of receiving a larger response. No read capacity
         * units are consumed.
         * The values returned are strongly consistent.
         */
        var returnValues: ReturnValue?
        /**
         * The name of the table containing the item to update.
         */
        var tableName: String?
        /**
         * An expression that defines one or more attributes to be updated, the action to be
         * performed on them, and new values for them.
         * The following action values are available for UpdateExpression.
         * SET - Adds one or more attributes and values to an item. If any of
         * these attributes already exist, they are replaced by the new values. You can
         * also use SET to add or subtract from an attribute that is of type
         * Number. For example: SET myNum = myNum + :val
         * SET supports the following functions:
         * if_not_exists (path, operand) - if the item does not contain an attribute at the specified path, then if_not_exists evaluates to operand; otherwise, it evaluates to path. You can use this function to avoid overwriting an attribute that may already be present in the item.
         * list_append (operand, operand) - evaluates to a list with a new element added to it. You can append the new element to the start or the end of the list by reversing the order of the operands.
         * These function names are case-sensitive.
         * REMOVE - Removes one or more attributes from an item.
         * ADD - Adds the specified value to the item, if the attribute does not already exist. If the attribute does exist, then the behavior of
         * ADD depends on the data type of the attribute:
         * If the existing attribute is a number, and if Value is also a number, then
         * Value is mathematically added to the existing attribute. If Value is a
         * negative number, then it is subtracted from the existing attribute.
         * If you use ADD to increment or decrement a number value for an item
         * that doesn't exist before the update, DynamoDB uses 0 as the initial
         * value.
         * Similarly, if you use ADD for an existing item to increment
         * or decrement an attribute value that doesn't exist before the
         * update, DynamoDB uses 0 as the initial value. For
         * example, suppose that the item you want to update doesn't have an
         * attribute named itemcount, but you decide to
         * ADD the number 3 to this attribute
         * anyway. DynamoDB will create the itemcount attribute,
         * set its initial value to 0, and finally add
         * 3 to it. The result will be a new
         * itemcount attribute in the item, with a value of
         * 3.
         * If the existing data type is a set and if Value is also a set, then
         * Value is added to the existing set. For example, if the attribute value is the set
         * &#91;1,2&#93;, and the ADD action specified &#91;3&#93;, then
         * the final attribute value is &#91;1,2,3&#93;. An error occurs if an ADD
         * action is specified for a set attribute and the attribute type specified does not
         * match the existing set type.
         * Both sets must have the same primitive data type. For example, if the existing data
         * type is a set of strings, the Value must also be a set of strings.
         * The ADD action only supports Number and set data types. In addition,
         * ADD can only be used on top-level attributes, not nested attributes.
         * DELETE - Deletes an element from a set.
         * If a set of values is specified, then those values are subtracted from the old
         * set. For example, if the attribute value was the set &#91;a,b,c&#93; and the
         * DELETE action specifies &#91;a,c&#93;, then the final attribute value
         * is &#91;b&#93;. Specifying an empty set is an error.
         * The DELETE action only supports set data types. In addition,
         * DELETE can only be used on top-level attributes, not nested attributes.
         * You can have many actions in a single expression, such as the following: SET a=:value1,
         * b=:value2 DELETE :value3, :value4, :value5
         * For more information on update expressions, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Modifying.html">Modifying Items and Attributes in the Amazon DynamoDB Developer Guide.
         */
        var updateExpression: String?

        fun build(): UpdateItemRequest
    }

    private class BuilderImpl() : FluentBuilder, DslBuilder {
        override var attributeUpdates: Map<String, AttributeValueUpdate>? = null
        override var conditionExpression: String? = null
        override var conditionalOperator: ConditionalOperator? = null
        override var expected: Map<String, ExpectedAttributeValue>? = null
        override var expressionAttributeNames: Map<String, String>? = null
        override var expressionAttributeValues: Map<String, AttributeValue>? = null
        override var key: Map<String, AttributeValue>? = null
        override var returnConsumedCapacity: ReturnConsumedCapacity? = null
        override var returnItemCollectionMetrics: ReturnItemCollectionMetrics? = null
        override var returnValues: ReturnValue? = null
        override var tableName: String? = null
        override var updateExpression: String? = null

        constructor(x: UpdateItemRequest) : this() {
            this.attributeUpdates = x.attributeUpdates
            this.conditionExpression = x.conditionExpression
            this.conditionalOperator = x.conditionalOperator
            this.expected = x.expected
            this.expressionAttributeNames = x.expressionAttributeNames
            this.expressionAttributeValues = x.expressionAttributeValues
            this.key = x.key
            this.returnConsumedCapacity = x.returnConsumedCapacity
            this.returnItemCollectionMetrics = x.returnItemCollectionMetrics
            this.returnValues = x.returnValues
            this.tableName = x.tableName
            this.updateExpression = x.updateExpression
        }

        override fun build(): UpdateItemRequest = UpdateItemRequest(this)
        override fun attributeUpdates(attributeUpdates: Map<String, AttributeValueUpdate>): FluentBuilder = apply { this.attributeUpdates = attributeUpdates }
        override fun conditionExpression(conditionExpression: String): FluentBuilder = apply { this.conditionExpression = conditionExpression }
        override fun conditionalOperator(conditionalOperator: ConditionalOperator): FluentBuilder = apply { this.conditionalOperator = conditionalOperator }
        override fun expected(expected: Map<String, ExpectedAttributeValue>): FluentBuilder = apply { this.expected = expected }
        override fun expressionAttributeNames(expressionAttributeNames: Map<String, String>): FluentBuilder = apply { this.expressionAttributeNames = expressionAttributeNames }
        override fun expressionAttributeValues(expressionAttributeValues: Map<String, AttributeValue>): FluentBuilder = apply { this.expressionAttributeValues = expressionAttributeValues }
        override fun key(key: Map<String, AttributeValue>): FluentBuilder = apply { this.key = key }
        override fun returnConsumedCapacity(returnConsumedCapacity: ReturnConsumedCapacity): FluentBuilder = apply { this.returnConsumedCapacity = returnConsumedCapacity }
        override fun returnItemCollectionMetrics(returnItemCollectionMetrics: ReturnItemCollectionMetrics): FluentBuilder = apply { this.returnItemCollectionMetrics = returnItemCollectionMetrics }
        override fun returnValues(returnValues: ReturnValue): FluentBuilder = apply { this.returnValues = returnValues }
        override fun tableName(tableName: String): FluentBuilder = apply { this.tableName = tableName }
        override fun updateExpression(updateExpression: String): FluentBuilder = apply { this.updateExpression = updateExpression }
    }
}
