// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package aws.sdk.kotlin.services.dynamodb.model



/**
 * Represents the input of an UpdateTable operation.
 */
class UpdateTableRequest private constructor(builder: BuilderImpl) {
    /**
     * An array of attributes that describe the key schema for the table and indexes. If you are adding a new global secondary index to the table, AttributeDefinitions must include the key element(s) of the new index.
     */
    val attributeDefinitions: List<AttributeDefinition>? = builder.attributeDefinitions
    /**
     * Controls how you are charged for read and write throughput and how you manage capacity.
     * When switching from pay-per-request to provisioned capacity, initial provisioned capacity values must be set. The initial
     * provisioned capacity values are estimated based on the consumed read and write capacity of your table and global secondary indexes
     * over the past 30 minutes.
     * PROVISIONED - We recommend using PROVISIONED for predictable workloads. PROVISIONED sets the billing mode to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual">Provisioned Mode.
     * PAY_PER_REQUEST - We recommend using PAY_PER_REQUEST for unpredictable workloads. PAY_PER_REQUEST sets the billing mode to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand">On-Demand Mode.
     */
    val billingMode: BillingMode? = builder.billingMode
    /**
     * An array of one or more global secondary indexes for the table. For each index in the array, you can request one action:
     * Create - add a new global secondary index to the table.
     * Update - modify the provisioned throughput settings of an existing global secondary index.
     * Delete - remove a global secondary index from the table.
     * You can create or delete only one global secondary index per UpdateTable operation.
     * For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.OnlineOps.html">Managing Global Secondary
     * Indexes in the Amazon DynamoDB Developer Guide.
     */
    val globalSecondaryIndexUpdates: List<GlobalSecondaryIndexUpdate>? = builder.globalSecondaryIndexUpdates
    /**
     * The new provisioned throughput settings for the specified table or index.
     */
    val provisionedThroughput: ProvisionedThroughput? = builder.provisionedThroughput
    /**
     * A list of replica update actions (create, delete, or update) for the table.
     * This property only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 of global tables.
     */
    val replicaUpdates: List<ReplicationGroupUpdate>? = builder.replicaUpdates
    /**
     * The new server-side encryption settings for the specified table.
     */
    val sseSpecification: SseSpecification? = builder.sseSpecification
    /**
     * Represents the DynamoDB Streams configuration for the table.
     * You receive a ResourceInUseException if you try to enable a stream on a
     * table that already has a stream, or if you try to disable a stream on a table that
     * doesn't have a stream.
     */
    val streamSpecification: StreamSpecification? = builder.streamSpecification
    /**
     * The name of the table to be updated.
     */
    val tableName: String? = builder.tableName

    companion object {
        @JvmStatic
        fun fluentBuilder(): FluentBuilder = BuilderImpl()

        internal fun builder(): DslBuilder = BuilderImpl()

        operator fun invoke(block: DslBuilder.() -> kotlin.Unit): UpdateTableRequest = BuilderImpl().apply(block).build()

    }

    override fun toString(): kotlin.String = buildString {
        append("UpdateTableRequest(")
        append("attributeDefinitions=$attributeDefinitions,")
        append("billingMode=$billingMode,")
        append("globalSecondaryIndexUpdates=$globalSecondaryIndexUpdates,")
        append("provisionedThroughput=$provisionedThroughput,")
        append("replicaUpdates=$replicaUpdates,")
        append("sseSpecification=$sseSpecification,")
        append("streamSpecification=$streamSpecification,")
        append("tableName=$tableName)")
    }

    override fun hashCode(): kotlin.Int {
        var result = attributeDefinitions?.hashCode() ?: 0
        result = 31 * result + (billingMode?.hashCode() ?: 0)
        result = 31 * result + (globalSecondaryIndexUpdates?.hashCode() ?: 0)
        result = 31 * result + (provisionedThroughput?.hashCode() ?: 0)
        result = 31 * result + (replicaUpdates?.hashCode() ?: 0)
        result = 31 * result + (sseSpecification?.hashCode() ?: 0)
        result = 31 * result + (streamSpecification?.hashCode() ?: 0)
        result = 31 * result + (tableName?.hashCode() ?: 0)
        return result
    }

    override fun equals(other: kotlin.Any?): kotlin.Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as UpdateTableRequest

        if (attributeDefinitions != other.attributeDefinitions) return false
        if (billingMode != other.billingMode) return false
        if (globalSecondaryIndexUpdates != other.globalSecondaryIndexUpdates) return false
        if (provisionedThroughput != other.provisionedThroughput) return false
        if (replicaUpdates != other.replicaUpdates) return false
        if (sseSpecification != other.sseSpecification) return false
        if (streamSpecification != other.streamSpecification) return false
        if (tableName != other.tableName) return false

        return true
    }

    fun copy(block: DslBuilder.() -> kotlin.Unit = {}): UpdateTableRequest = BuilderImpl(this).apply(block).build()

    interface FluentBuilder {
        fun build(): UpdateTableRequest
        /**
         * An array of attributes that describe the key schema for the table and indexes. If you are adding a new global secondary index to the table, AttributeDefinitions must include the key element(s) of the new index.
         */
        fun attributeDefinitions(attributeDefinitions: List<AttributeDefinition>): FluentBuilder
        /**
         * Controls how you are charged for read and write throughput and how you manage capacity.
         * When switching from pay-per-request to provisioned capacity, initial provisioned capacity values must be set. The initial
         * provisioned capacity values are estimated based on the consumed read and write capacity of your table and global secondary indexes
         * over the past 30 minutes.
         * PROVISIONED - We recommend using PROVISIONED for predictable workloads. PROVISIONED sets the billing mode to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual">Provisioned Mode.
         * PAY_PER_REQUEST - We recommend using PAY_PER_REQUEST for unpredictable workloads. PAY_PER_REQUEST sets the billing mode to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand">On-Demand Mode.
         */
        fun billingMode(billingMode: BillingMode): FluentBuilder
        /**
         * An array of one or more global secondary indexes for the table. For each index in the array, you can request one action:
         * Create - add a new global secondary index to the table.
         * Update - modify the provisioned throughput settings of an existing global secondary index.
         * Delete - remove a global secondary index from the table.
         * You can create or delete only one global secondary index per UpdateTable operation.
         * For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.OnlineOps.html">Managing Global Secondary
         * Indexes in the Amazon DynamoDB Developer Guide.
         */
        fun globalSecondaryIndexUpdates(globalSecondaryIndexUpdates: List<GlobalSecondaryIndexUpdate>): FluentBuilder
        /**
         * The new provisioned throughput settings for the specified table or index.
         */
        fun provisionedThroughput(provisionedThroughput: ProvisionedThroughput): FluentBuilder
        /**
         * A list of replica update actions (create, delete, or update) for the table.
         * This property only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 of global tables.
         */
        fun replicaUpdates(replicaUpdates: List<ReplicationGroupUpdate>): FluentBuilder
        /**
         * The new server-side encryption settings for the specified table.
         */
        fun sseSpecification(sseSpecification: SseSpecification): FluentBuilder
        /**
         * Represents the DynamoDB Streams configuration for the table.
         * You receive a ResourceInUseException if you try to enable a stream on a
         * table that already has a stream, or if you try to disable a stream on a table that
         * doesn't have a stream.
         */
        fun streamSpecification(streamSpecification: StreamSpecification): FluentBuilder
        /**
         * The name of the table to be updated.
         */
        fun tableName(tableName: String): FluentBuilder
    }

    interface DslBuilder {
        /**
         * An array of attributes that describe the key schema for the table and indexes. If you are adding a new global secondary index to the table, AttributeDefinitions must include the key element(s) of the new index.
         */
        var attributeDefinitions: List<AttributeDefinition>?
        /**
         * Controls how you are charged for read and write throughput and how you manage capacity.
         * When switching from pay-per-request to provisioned capacity, initial provisioned capacity values must be set. The initial
         * provisioned capacity values are estimated based on the consumed read and write capacity of your table and global secondary indexes
         * over the past 30 minutes.
         * PROVISIONED - We recommend using PROVISIONED for predictable workloads. PROVISIONED sets the billing mode to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual">Provisioned Mode.
         * PAY_PER_REQUEST - We recommend using PAY_PER_REQUEST for unpredictable workloads. PAY_PER_REQUEST sets the billing mode to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand">On-Demand Mode.
         */
        var billingMode: BillingMode?
        /**
         * An array of one or more global secondary indexes for the table. For each index in the array, you can request one action:
         * Create - add a new global secondary index to the table.
         * Update - modify the provisioned throughput settings of an existing global secondary index.
         * Delete - remove a global secondary index from the table.
         * You can create or delete only one global secondary index per UpdateTable operation.
         * For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.OnlineOps.html">Managing Global Secondary
         * Indexes in the Amazon DynamoDB Developer Guide.
         */
        var globalSecondaryIndexUpdates: List<GlobalSecondaryIndexUpdate>?
        /**
         * The new provisioned throughput settings for the specified table or index.
         */
        var provisionedThroughput: ProvisionedThroughput?
        /**
         * A list of replica update actions (create, delete, or update) for the table.
         * This property only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 of global tables.
         */
        var replicaUpdates: List<ReplicationGroupUpdate>?
        /**
         * The new server-side encryption settings for the specified table.
         */
        var sseSpecification: SseSpecification?
        /**
         * Represents the DynamoDB Streams configuration for the table.
         * You receive a ResourceInUseException if you try to enable a stream on a
         * table that already has a stream, or if you try to disable a stream on a table that
         * doesn't have a stream.
         */
        var streamSpecification: StreamSpecification?
        /**
         * The name of the table to be updated.
         */
        var tableName: String?

        fun build(): UpdateTableRequest
        /**
         * construct an [aws.sdk.kotlin.services.dynamodb.model.ProvisionedThroughput] inside the given [block]
         */
        fun provisionedThroughput(block: ProvisionedThroughput.DslBuilder.() -> kotlin.Unit) {
            this.provisionedThroughput = ProvisionedThroughput.invoke(block)
        }
        /**
         * construct an [aws.sdk.kotlin.services.dynamodb.model.SseSpecification] inside the given [block]
         */
        fun sseSpecification(block: SseSpecification.DslBuilder.() -> kotlin.Unit) {
            this.sseSpecification = SseSpecification.invoke(block)
        }
        /**
         * construct an [aws.sdk.kotlin.services.dynamodb.model.StreamSpecification] inside the given [block]
         */
        fun streamSpecification(block: StreamSpecification.DslBuilder.() -> kotlin.Unit) {
            this.streamSpecification = StreamSpecification.invoke(block)
        }
    }

    private class BuilderImpl() : FluentBuilder, DslBuilder {
        override var attributeDefinitions: List<AttributeDefinition>? = null
        override var billingMode: BillingMode? = null
        override var globalSecondaryIndexUpdates: List<GlobalSecondaryIndexUpdate>? = null
        override var provisionedThroughput: ProvisionedThroughput? = null
        override var replicaUpdates: List<ReplicationGroupUpdate>? = null
        override var sseSpecification: SseSpecification? = null
        override var streamSpecification: StreamSpecification? = null
        override var tableName: String? = null

        constructor(x: UpdateTableRequest) : this() {
            this.attributeDefinitions = x.attributeDefinitions
            this.billingMode = x.billingMode
            this.globalSecondaryIndexUpdates = x.globalSecondaryIndexUpdates
            this.provisionedThroughput = x.provisionedThroughput
            this.replicaUpdates = x.replicaUpdates
            this.sseSpecification = x.sseSpecification
            this.streamSpecification = x.streamSpecification
            this.tableName = x.tableName
        }

        override fun build(): UpdateTableRequest = UpdateTableRequest(this)
        override fun attributeDefinitions(attributeDefinitions: List<AttributeDefinition>): FluentBuilder = apply { this.attributeDefinitions = attributeDefinitions }
        override fun billingMode(billingMode: BillingMode): FluentBuilder = apply { this.billingMode = billingMode }
        override fun globalSecondaryIndexUpdates(globalSecondaryIndexUpdates: List<GlobalSecondaryIndexUpdate>): FluentBuilder = apply { this.globalSecondaryIndexUpdates = globalSecondaryIndexUpdates }
        override fun provisionedThroughput(provisionedThroughput: ProvisionedThroughput): FluentBuilder = apply { this.provisionedThroughput = provisionedThroughput }
        override fun replicaUpdates(replicaUpdates: List<ReplicationGroupUpdate>): FluentBuilder = apply { this.replicaUpdates = replicaUpdates }
        override fun sseSpecification(sseSpecification: SseSpecification): FluentBuilder = apply { this.sseSpecification = sseSpecification }
        override fun streamSpecification(streamSpecification: StreamSpecification): FluentBuilder = apply { this.streamSpecification = streamSpecification }
        override fun tableName(tableName: String): FluentBuilder = apply { this.tableName = tableName }
    }
}
